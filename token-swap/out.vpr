domain Snap$m_Path$_beg_$_end_ {
  
  function discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self: Snap$m_Path$_beg_$_end_): Int
  
  function cons$0$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_(): Snap$m_Path$_beg_$_end_
  
  function cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0: Int, _1: Int): Snap$m_Path$_beg_$_end_
  
  function Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self: Snap$m_Path$_beg_$_end_): Int
  
  function Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self: Snap$m_Path$_beg_$_end_): Int
  
  axiom Snap$m_Path$_beg_$_end_$discriminant_range {
    (forall self: Snap$m_Path$_beg_$_end_ :: { discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self) } 0 <= discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self) && discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self) <= 1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$0$discriminant_axiom {
    discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(cons$0$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_()) == 0
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$injectivity {
    (forall _l_0: Int, _l_1: Int, _r_0: Int, _r_1: Int :: { cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_l_0, _l_1),cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_r_0, _r_1) } cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_l_0, _l_1) == cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_r_0, _r_1) ==> _l_0 == _r_0 && _l_1 == _r_1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$discriminant_axiom {
    (forall _0: Int, _1: Int :: { cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1) } discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) == 1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$0$axiom {
    (forall _0: Int, _1: Int :: { Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) } Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) == _0)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$0$valid {
    (forall self: Snap$m_Path$_beg_$_end_ :: { Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) } 0 <= Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) && Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) <= 4294967295)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$1$axiom {
    (forall _0: Int, _1: Int :: { Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) } Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) == _1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$1$valid {
    (forall self: Snap$m_Path$_beg_$_end_ :: { Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) } 0 <= Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) && Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) <= 4294967295)
  }
}

field discriminant: Int

field enum_Cons: Ref

field f$0: Ref

field f$1: Ref

field tuple_0: Ref

field tuple_1: Ref

field val_bool: Bool

field val_int: Int

field val_ref: Ref

function m_Path$_beg_$_end_$$discriminant$$__$TY$__m_Path$_beg_$_end_$$int$(self: Ref): Int
  requires acc(m_Path$_beg_$_end_(self), read$())
  ensures 0 <= result && result <= 1
  ensures discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(snap$__$TY$__Snap$m_Path$_beg_$_end_$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_(self)) == result
{
  (unfolding acc(m_Path$_beg_$_end_(self), read$()) in self.discriminant)
}

function snap$__$TY$__Snap$m_Path$_beg_$_end_$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_(self: Ref): Snap$m_Path$_beg_$_end_
  requires acc(m_Path$_beg_$_end_(self), read$())
{
  ((unfolding acc(m_Path$_beg_$_end_(self), read$()) in self.discriminant) == 1 ? cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_((unfolding acc(m_Path$_beg_$_end_(self), read$()) in (unfolding acc(m_Path$_beg_$_end_Cons(self.enum_Cons), read$()) in (unfolding acc(u32(self.enum_Cons.f$0), read$()) in self.enum_Cons.f$0.val_int))), (unfolding acc(m_Path$_beg_$_end_(self), read$()) in (unfolding acc(m_Path$_beg_$_end_Cons(self.enum_Cons), read$()) in (unfolding acc(u32(self.enum_Cons.f$1), read$()) in self.enum_Cons.f$1.val_int)))) : cons$0$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_())
}

function read$(): Perm
  ensures none < result
  ensures result < write


predicate DeadBorrowToken$(borrow: Int) 

predicate bool(self: Ref) {
  acc(self.val_bool, write)
}

predicate m_Path$_beg_$_end_(self: Ref) {
  acc(self.discriminant, write) && (0 <= self.discriminant && (self.discriminant <= 1 && (acc(self.enum_Cons, write) && acc(m_Path$_beg_$_end_Cons(self.enum_Cons), write))))
}

predicate m_Path$_beg_$_end_Cons(self: Ref) {
  acc(self.f$0, write) && (acc(u32(self.f$0), write) && (acc(self.f$1, write) && acc(u32(self.f$1), write)))
}

predicate ref$m_Path$_beg_$_end_(self: Ref) 

predicate tuple2$ref$m_Path$_beg_$_end_$ref$m_Path$_beg_$_end_(self: Ref) {
  acc(self.tuple_0, write) && (acc(ref$m_Path$_beg_$_end_(self.tuple_0), write) && (acc(self.tuple_1, write) && acc(ref$m_Path$_beg_$_end_(self.tuple_1), write)))
}

predicate u32(self: Ref) {
  acc(self.val_int, write) && (0 <= self.val_int && self.val_int <= 4294967295)
}

method m_path_eq() returns (_0: Ref)
{
  var __t0: Bool
  var __t1: Bool
  var __t2: Bool
  var __t3: Bool
  var __t4: Bool
  var __t5: Bool
  var __t6: Bool
  var __t7: Bool
  var __t8: Bool
  var _aux_havoc_ref$m_Path$_beg_$_end_: Ref
  var __t9: Int
  var __t10: Int
  var __t11: Bool
  var _old$pre$0: Ref
  var _old$pre$1: Ref
  var _1: Ref
  var _2: Ref
  var _3: Ref
  var _4: Ref
  var _5: Ref
  var _6: Int
  var _7: Int
  var _8: Ref
  var _9: Ref
  var _10: Ref
  var _11: Ref
  var _12: Ref
  var _13: Int
  var _14: Int
  var _15: Ref
  var _16: Int
  var _17: Int
  label start
  __t0 := false
  __t1 := false
  __t2 := false
  __t3 := false
  __t4 := false
  __t5 := false
  __t6 := false
  __t7 := false
  __t8 := false
  inhale acc(_1.val_ref, write) && (acc(m_Path$_beg_$_end_(_1.val_ref), read$()) && (acc(_2.val_ref, write) && acc(m_Path$_beg_$_end_(_2.val_ref), read$())))
  label pre
  __t0 := true
  _4 := builtin$havoc_ref()
  inhale acc(_4.val_ref, write)
  _4.val_ref := _1.val_ref
  inhale acc(m_Path$_beg_$_end_(_4.val_ref), read$())
  label l0
  _5 := builtin$havoc_ref()
  inhale acc(_5.val_ref, write)
  _5.val_ref := _2.val_ref
  inhale acc(m_Path$_beg_$_end_(_5.val_ref), read$())
  label l1
  _3 := builtin$havoc_ref()
  inhale acc(tuple2$ref$m_Path$_beg_$_end_$ref$m_Path$_beg_$_end_(_3), write)
  _aux_havoc_ref$m_Path$_beg_$_end_ := builtin$havoc_ref()
  unfold acc(tuple2$ref$m_Path$_beg_$_end_$ref$m_Path$_beg_$_end_(_3), write)
  _3.tuple_0 := _aux_havoc_ref$m_Path$_beg_$_end_
  inhale acc(_3.tuple_0.val_ref, write)
  _3.tuple_0.val_ref := _4.val_ref
  label l2
  _aux_havoc_ref$m_Path$_beg_$_end_ := builtin$havoc_ref()
  _3.tuple_1 := _aux_havoc_ref$m_Path$_beg_$_end_
  inhale acc(_3.tuple_1.val_ref, write)
  _3.tuple_1.val_ref := _5.val_ref
  label l3
  _7 := builtin$havoc_int()
  _7 := m_Path$_beg_$_end_$$discriminant$$__$TY$__m_Path$_beg_$_end_$$int$(_3.tuple_0.val_ref)
  __t9 := _7
  if (__t9 == 1) {
    goto bb0
  }
  goto return
  label bb0
  __t1 := true
  _6 := builtin$havoc_int()
  _6 := m_Path$_beg_$_end_$$discriminant$$__$TY$__m_Path$_beg_$_end_$$int$(_3.tuple_1.val_ref)
  __t10 := _6
  if (__t10 == 1) {
    goto bb2
  }
  goto l4
  label bb1
  __t7 := true
  goto bb3
  label bb2
  __t3 := true
  __t4 := true
  _8 := builtin$havoc_ref()
  inhale acc(_8.val_ref, write)
  unfold acc(m_Path$_beg_$_end_(_3.tuple_0.val_ref), read$())
  unfold acc(m_Path$_beg_$_end_Cons(_3.tuple_0.val_ref.enum_Cons), read$())
  _8.val_ref := _3.tuple_0.val_ref.enum_Cons.f$0
  inhale acc(u32(_8.val_ref), read$())
  label l8
  _9 := builtin$havoc_ref()
  inhale acc(_9.val_ref, write)
  _9.val_ref := _3.tuple_0.val_ref.enum_Cons.f$1
  inhale acc(u32(_9.val_ref), read$())
  label l9
  _10 := builtin$havoc_ref()
  inhale acc(_10.val_ref, write)
  unfold acc(m_Path$_beg_$_end_(_3.tuple_1.val_ref), read$())
  unfold acc(m_Path$_beg_$_end_Cons(_3.tuple_1.val_ref.enum_Cons), read$())
  _10.val_ref := _3.tuple_1.val_ref.enum_Cons.f$0
  inhale acc(u32(_10.val_ref), read$())
  label l10
  _11 := builtin$havoc_ref()
  inhale acc(_11.val_ref, write)
  _11.val_ref := _3.tuple_1.val_ref.enum_Cons.f$1
  inhale acc(u32(_11.val_ref), read$())
  label l11
  _13 := builtin$havoc_int()
  unfold acc(u32(_8.val_ref), read$())
  _13 := _8.val_ref.val_int
  label l12
  if (__t4) {
    fold acc(u32(_8.val_ref), read$())
    exhale acc(u32(_8.val_ref), read$())
  }
  _14 := builtin$havoc_int()
  unfold acc(u32(_10.val_ref), read$())
  _14 := _10.val_ref.val_int
  label l13
  if (__t4) {
    fold acc(u32(_10.val_ref), read$())
    exhale acc(u32(_10.val_ref), read$())
  }
  _12 := builtin$havoc_ref()
  inhale acc(_12.val_bool, write)
  _12.val_bool := _13 == _14
  __t11 := _12.val_bool
  if (!__t11) {
    goto l7
  }
  goto l6
  label bb3
  __t8 := true
  label l20
  _old$pre$0 := _1.val_ref
  _old$pre$1 := _2.val_ref
  fold acc(bool(_0), write)
  assert true
  exhale acc(m_Path$_beg_$_end_(_old$pre$0), read$()) && acc(m_Path$_beg_$_end_(_old$pre$1), read$())
  exhale acc(bool(_0), write)
  goto end_of_method
  label l4
  if (__t0) {
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
  }
  if (__t0) {
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
  }
  goto l5
  label l5
  __t2 := true
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := true
  goto bb3
  label l6
  __t5 := true
  _16 := builtin$havoc_int()
  unfold acc(u32(_9.val_ref), read$())
  _16 := _9.val_ref.val_int
  label l16
  if (__t4) {
    fold acc(u32(_9.val_ref), read$())
    exhale acc(u32(_9.val_ref), read$())
  }
  if (__t0 && __t4) {
    fold acc(m_Path$_beg_$_end_Cons(old[l0](_4.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
  }
  _17 := builtin$havoc_int()
  unfold acc(u32(_11.val_ref), read$())
  _17 := _11.val_ref.val_int
  label l17
  if (__t4) {
    fold acc(u32(_11.val_ref), read$())
    exhale acc(u32(_11.val_ref), read$())
  }
  if (__t0 && __t4) {
    fold acc(m_Path$_beg_$_end_Cons(old[l1](_5.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
  }
  _15 := builtin$havoc_ref()
  inhale acc(_15.val_bool, write)
  _15.val_bool := _16 == _17
  _0 := _15
  label l18
  goto bb1
  label l7
  if (__t4) {
    exhale acc(u32(_11.val_ref), read$())
  }
  if (__t0 && __t4) {
    fold acc(m_Path$_beg_$_end_Cons(old[l1](_5.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    fold acc(m_Path$_beg_$_end_Cons(_3.tuple_0.val_ref.enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(_3.tuple_0.val_ref), read$())
  }
  if (__t4) {
    exhale acc(u32(_9.val_ref), read$())
  }
  if (__t0 && __t4) {
    fold acc(m_Path$_beg_$_end_Cons(old[l0](_4.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
  }
  __t6 := true
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := false
  goto bb1
  label return
  if (__t0) {
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
  }
  if (__t0) {
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
  }
  goto l5
  label end_of_method
}

method builtin$havoc_bool() returns (ret: Bool)


method builtin$havoc_int() returns (ret: Int)


method builtin$havoc_ref() returns (ret: Ref)
