// GHOST 

domain Resource {
    function mkResource(id: Int): Resource
    function toResource(bank: Ref, acctID: AccountID, coin: Coin, path: Path): Resource

    axiom toResourceInv {
        forall 
            bank1 : Ref, 
            bank2: Ref, 
            acctID1: AccountID, 
            acctID2: AccountID, 
            coin1: Coin, 
            coin2: Coin, 
            path1: Path, 
            path2: Path ::
            
            (bank1 != bank2 || acctID1 != acctID2 || coin1 != coin2 || path1 != path2) ==>
            toResource(bank1, acctID1, coin1, path1) != toResource(bank2, acctID2, coin2, path2)

    }
}

predicate Owns(resource: Resource)

define owns(resource, amount) (
    acc(Owns(resource), amount / 1)
)

method ghostMint(
    resource: Resource,
    amount: Int
) 
   requires amount >= 0
   ensures owns(resource, amount)

method ghostBurn(
    resource: Resource,
    amount: Int
) 
   requires amount >= 0
   requires owns(resource, amount)


// NONGHOST

domain Coin {}

domain BankBalances {
    function balanceOf(
        bank: BankBalances,
        acctID: AccountID,
        coin: Coin,
        path: Path
    ): Int

    function adjustAmount(
        bank: BankBalances,
        acctID: AccountID,
        coin: Coin,
        path: Path,
        amt: Int
    ): BankBalances

    function bbEq(
        bank1: BankBalances,
        bank2: BankBalances
    ): Bool

    axiom extEq {
        forall bank1: BankBalances, bank2: BankBalances ::
          bbEq(bank1, bank2) == (forall acctID : AccountID, coin: Coin, path: Path ::
            balanceOf(bank1, acctID, coin, path) == balanceOf(bank2, acctID, coin, path))
    }

    axiom balancesPositive {
        forall bank: BankBalances, acctID: AccountID, coin: Coin, path: Path ::
            balanceOf(bank, acctID, coin, path) >= 0
    }

    axiom axiomAdjustAmount {
        forall bank: BankBalances, acctID: AccountID, coin: Coin, path: Path, amt: Int ::
            let newBank == (adjustAmount(bank, acctID, coin, path, amt))
            in forall acctID2: AccountID, coin2: Coin, path2: Path :: (
                balanceOf(newBank, acctID2, coin2, path2) ==
                ((acctID == acctID2 && coin == coin2 && path == path2) ?
                balanceOf(bank, acctID2, coin2, path2) + amt :
                balanceOf(bank, acctID2, coin2, path2))
            )
    }
}

field bankBalances: BankBalances

domain AccountID { }

adt Path {
    Empty()

    Cons(
        headPort: Port,
        headChannel: ChannelEnd,
        tail: Path
    )
}

define startsWith(path, port, channel) (
    path.isCons && path.headPort == port && path.headChannel == channel
)

define prependPrefix(path, port, channel) (
    Cons(port, channel, path)
)

function dropPrefix(path: Path, port: Port, channel: ChannelEnd): Path 
  requires(startsWith(path, port, channel))
{
    path.tail
}

define updateBalance(bank, acctID, path, coin, amt){
    bank.bankBalances := adjustAmount(bank.bankBalances, acctID, coin, path, amt)
}

define bankPost(bank) (
forall acctID: AccountID, c: Coin, p : Path :: 
  (balanceOf(bank.bankBalances, acctID, c, p) - 
   balanceOf(old(bank.bankBalances), acctID, c, p)) / 1
      == perm(Owns(toResource(bank, acctID, c, p))) 
      - old(perm(Owns(toResource(bank, acctID, c, p))))

)

define bankPostPreExhale(bank) (
    [true, bankPost(bank)]
)

define bankPostPostExhale(bank) (
    [bankPost(bank), true]
)

method bankMintTokens(
    bank: Ref,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires acc(bank.bankBalances)
    requires amt >= 0
    ensures acc(bank.bankBalances)
    ensures bankPostPreExhale(bank)
    ensures owns(toResource(bank, to, coin, path), amt)
    ensures bankPostPostExhale(bank)
    ensures success
{
    ghostMint(toResource(bank, to, coin, path), amt)
    updateBalance(bank, to, path, coin, amt)
    success := true
}

define bankBurnTokensPre(bankBalances, from, path, coin, amt) (
    balanceOf(bankBalances, from, coin, path) >= amt
)

method bankBurnTokens(
    bank: Ref,
    from: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires acc(bank.bankBalances)
    requires amt >= 0
    requires bankBurnTokensPre(bank.bankBalances, from, path, coin, amt) ==> owns(toResource(bank, from, coin, path), amt)
    ensures acc(bank.bankBalances)
    ensures success == bankBurnTokensPre(old(bank.bankBalances), from, path, coin, amt)
    ensures bankPostPreExhale(bank)
    ensures bankPostPostExhale(bank)
{
    if(bankBurnTokensPre(bank.bankBalances, from, path, coin, amt)) {
        ghostBurn(
            toResource(bank, from, coin, path),
            amt
        )
        updateBalance(bank, from, path, coin, 0 - amt)
        success := true
    } else {
        success := false
    }
}

define bankTransferTokensPre(bankBalances, from, to, path, coin, amt) (
    from != to && balanceOf(bankBalances, from, coin, path) >= amt
)

method bankTransferTokens(
    bank: Ref,
    from: AccountID,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires amt >= 0
    requires acc(bank.bankBalances)
    requires bankTransferTokensPre(bank.bankBalances, from, to, path, coin, amt) ==> owns(
        toResource(bank, from, coin, path),
        amt
    )
    ensures acc(bank.bankBalances)
    ensures bankPostPreExhale(bank)
    ensures success ==> owns(toResource(bank, to, coin, path), amt)
    ensures bankPostPostExhale(bank)
    ensures success == bankTransferTokensPre(old(bank.bankBalances), from, to, path, coin, amt)
{
    if(bankTransferTokensPre(bank.bankBalances, from, to, path, coin, amt)) {
       ghostMint(toResource(bank, to, coin, path), amt)
       ghostBurn(toResource(bank, from, coin, path), amt)
       updateBalance(bank, from, path, coin, (0 - amt))
       updateBalance(bank, to, path, coin, amt)
       success := true
    } else {
        success := false
    }
}

domain Port {
    function mkPort(id: Int): Port
}

domain ChannelEnd {
    function mkChannelEnd(id: Int): ChannelEnd
}


adt FungibleTokenPacketData {
    PacketData(
        path: Path,
        coin: Coin,
        sender: AccountID,
        receiver: AccountID,
        amount: Int
    )
}

adt Packet {
    _Packet(
        sourcePort: Port,
        sourceChannel: ChannelEnd,
        destPort: Port,
        destChannel: ChannelEnd,
        data: FungibleTokenPacketData
    )
}

function mkPacket(
  sourcePort: Port,
  sourceChannel: ChannelEnd,
  data: FungibleTokenPacketData
): Packet
  ensures result.sourcePort == sourcePort
  ensures result.sourceChannel == sourceChannel
  ensures result.data == data

adt FungibleTokenPacketAcknowledgement {
    Ack(
        success: Bool
    )
}

function escrowAddress(bank: Ref, channel: ChannelEnd): AccountID

define sendWillBurn(
    path, 
    sourcePort, 
    sourceChannel, 
    bankBalances, 
    sender, 
    coin, 
    amount) 
(
  startsWith(path, sourcePort, sourceChannel) && 
     bankBurnTokensPre(
        bankBalances,
        sender,
        path,
        coin,
        amount
     )
)

define sendWillTransfer(
    path,
    sourcePort,
    sourceChannel,
    bankBalances,
    sender,
    eAddress,
    coin,
    amount
) (
  !startsWith(path, sourcePort, sourceChannel) && 
     bankTransferTokensPre(
        bankBalances,
        sender,
        eAddress,
        path,
        coin,
        amount
     )
)

method sendFungibleTokens(
    bank: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd
) returns (success: Bool, packet: Packet)
   requires acc(bank.bankBalances)
   requires amount >= 0
   requires(
    sendWillBurn(path, sourcePort, sourceChannel, bank.bankBalances, sender, coin, amount) ||
    sendWillTransfer(path, 
        sourcePort, 
        sourceChannel, 
        bank.bankBalances, 
        sender, 
        escrowAddress(bank, sourceChannel), 
        coin, 
        amount
    ) ==> owns(toResource(bank, sender, coin, path), amount))
   ensures acc(bank.bankBalances)
   ensures bankPostPreExhale(bank)
   ensures(
    sendWillTransfer(
        path, 
        sourcePort, 
        sourceChannel, 
        old(bank.bankBalances), 
        sender, 
        escrowAddress(bank, sourceChannel), 
        coin, 
        amount
    ) ==> owns(toResource(bank, escrowAddress(bank, sourceChannel), coin, path), amount) && success)
   ensures(sendWillBurn(path, sourcePort, sourceChannel, old(bank.bankBalances), sender, coin, amount) ==> success)
   ensures bankPostPostExhale(bank)
   ensures success ==> (packet == mkPacket(sourcePort, sourceChannel, PacketData(path, coin, sender, receiver, amount)))
{
    if(!startsWith(path, sourcePort, sourceChannel)) {
        success := bankTransferTokens(
            bank,
            sender,
            escrowAddress(bank, sourceChannel),
            path,
            coin,
            amount
        )
    } else {
        success := bankBurnTokens(
            bank,
            sender,
            path,
            coin,
            amount
        )
    }
    var data: FungibleTokenPacketData := PacketData(
        path,
        coin,
        sender,
        receiver,
        amount
    )
    packet := mkPacket(sourcePort, sourceChannel, data)
}

method refundTokens(
    bank: Ref,
    packet: Packet
) 
    requires acc(bank.bankBalances)
    requires packet.data.amount >= 0
    requires (
        !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==>
        owns(
            toResource(
                bank, 
                escrowAddress(bank, packet.sourceChannel), 
                packet.data.coin, 
                packet.data.path
            ), packet.data.amount
        )
    )
    ensures acc(bank.bankBalances)
    ensures bankPostPreExhale(bank)
    ensures bankPostPostExhale(bank)
{
    var success: Bool

    if(!startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.sourceChannel),
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount
        )

    }
}

define packetIsSource(packet) (
    startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)
)

method onRecvPacket(
    bank: Ref,
    packet: Packet
) returns (ack: FungibleTokenPacketAcknowledgement) 
    requires acc(bank.bankBalances)
    requires packet.data.amount >= 0
    requires(
        packetIsSource(packet) &&
        bankTransferTokensPre(
            bank.bankBalances,
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount) ==> owns(
                toResource(
                    bank,
                    escrowAddress(bank, packet.destChannel),
                    packet.data.coin,
                    dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel)
                ),
                packet.data.amount
            )
    )
    ensures acc(bank.bankBalances)
    ensures bankPostPreExhale(bank)
    ensures(
        packetIsSource(packet) &&
        bankTransferTokensPre(
            old(bank.bankBalances),
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount) ==> 
            ack.success && owns(
                    toResource(
                        bank, 
                        packet.data.receiver, 
                        packet.data.coin,
                        packet.data.path.tail
                    ),
                    packet.data.amount
                )
    )
    ensures(!packetIsSource(packet) ==> ack.success && owns(
        toResource(
            bank,
            packet.data.receiver,
            packet.data.coin,
            prependPrefix(packet.data.path, packet.destPort, packet.destChannel)
        ),
        packet.data.amount
    ))
    ensures bankPostPostExhale(bank)
{
    var success: Bool
    if(packetIsSource(packet)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.receiver,
            prependPrefix(packet.data.path, packet.destPort, packet.destChannel),
            packet.data.coin,
            packet.data.amount
        )
    }
    ack := Ack(success)
}

method onAcknowledgePacket(
    bank: Ref,
    ack: FungibleTokenPacketAcknowledgement,
    packet: Packet
) 
    requires acc(bank.bankBalances)
    requires packet.data.amount >= 0
    requires !ack.success ==> owns(
        toResource(
            bank, 
            escrowAddress(bank, packet.sourceChannel), 
            packet.data.coin, 
            packet.data.path
        ), packet.data.amount
    )
    ensures acc(bank.bankBalances)
    ensures bankPostPreExhale(bank)
    ensures bankPostPostExhale(bank)
{
    if(!ack.success) {
        refundTokens(bank, packet)
    } else {

    }

}

method roundTrip(
    bank1: Ref,
    bank2: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd,
    destPort: Port,
    destChannel: ChannelEnd
) 
    requires acc(bank1.bankBalances)
    requires acc(bank2.bankBalances)
    requires bank1 != bank2
    requires amount >= 0
    requires !startsWith(path, sourcePort, sourceChannel)
    requires bankTransferTokensPre(
        bank1.bankBalances,
        sender,
        escrowAddress(bank1, sourceChannel),
        path,
        coin,
        amount
    )
    requires owns(toResource(bank1, sender, coin, path), amount)
    ensures acc(bank1.bankBalances)
    ensures acc(bank2.bankBalances)
    ensures bankPostPreExhale(bank1)
    ensures bankPostPostExhale(bank1)
    ensures bankPostPreExhale(bank2)
    ensures bankPostPostExhale(bank2)
    ensures bbEq(bank1.bankBalances, old(bank1.bankBalances))
    ensures bbEq(bank2.bankBalances, old(bank2.bankBalances))
{
    var success: Bool
    var packet: Packet

    success, packet := sendFungibleTokens(bank1, path, coin, amount, sender, receiver, sourcePort, sourceChannel)
    assert success
    assume packet.destPort == destPort
    assume packet.destChannel == destChannel

    var ack: FungibleTokenPacketAcknowledgement 
    ack := onRecvPacket(bank2, packet)
    assert ack.success
    onAcknowledgePacket(bank1, ack, packet)

    success, packet := sendFungibleTokens(
        bank2, 
        prependPrefix(path, destPort, destChannel), 
        coin, 
        amount, 
        receiver, 
        sender, 
        destPort, 
        destChannel
    )
    assume packet.destChannel == sourceChannel
    assume packet.destPort == sourcePort
    ack := onRecvPacket(bank1, packet)
    onAcknowledgePacket(bank2, ack, packet)
}