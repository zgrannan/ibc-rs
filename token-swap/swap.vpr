// GHOST 

domain ResourceHolder {
    // Accounts 
    function ghostBalance(rh: ResourceHolder, resource: Resource): Ref

    axiom balanceInjective {
        forall owner1: ResourceHolder, owner2: ResourceHolder, resource1: Resource, resource2: Resource :: 
        owner1 != owner2 || resource1 != resource2 ==> ghostBalance(owner1, resource1) != ghostBalance(owner2, resource2)
    }

    function mkResourceHolder(id: Int): ResourceHolder

}

function total(resources: Set[ResourceHolder], resource: Resource): Int
    requires forall r : ResourceHolder :: acc(ghostBalance(r, resource).resourceAmount)

domain Resource {
    function mkResource(id: Int): Resource
}

predicate CanTransfer(from: ResourceHolder, to: ResourceHolder, resource: Resource)
predicate CanMint(to: ResourceHolder, resource: Resource)
predicate CanBurn(to: ResourceHolder, resource: Resource)

define canTransfer(from, to, resource, amt) (
    acc(CanTransfer(from, to, resource), amt / 1)
)

define canMint(to, resource, amt) (
    acc(CanMint(to, resource), amt / 1)
)

define canBurn(to, resource, amount) (
    acc(CanBurn(to, resource), amount / 1)
)

// Field of returned ref from `balance`
field resourceAmount: Int

method ghostMint(
    to: ResourceHolder, 
    resource: Resource,
    amount: Int
) 
   requires acc(ghostBalance(to, resource).resourceAmount)
   requires(ghostBalance(to, resource).resourceAmount + amount >= 0)
   ensures acc(ghostBalance(to, resource).resourceAmount)
   ensures ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount
{
    ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
}

method ghostTransfer(
    from: ResourceHolder, 
    to: ResourceHolder, 
    resource: Resource,
    amount: Int
)
   requires acc(ghostBalance(from, resource).resourceAmount)
   requires acc(ghostBalance(to, resource).resourceAmount)
   requires(amount >= 0)
   requires(ghostBalance(from, resource).resourceAmount >= amount)
   requires canTransfer(from, to, resource, amount)
   ensures acc(ghostBalance(from, resource).resourceAmount)
   ensures acc(ghostBalance(to, resource).resourceAmount)
   ensures ghostBalance(from, resource).resourceAmount == old(ghostBalance(from, resource).resourceAmount) - amount
   ensures ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount

   // Sanity check: total sum of resource unchanged
   ensures (ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount) ==
           old(ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount)

{
    ghostBalance(from, resource).resourceAmount := ghostBalance(from, resource).resourceAmount - amount
    ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
}


// NONGHOST

field bankBalances: Map[AccountID, Map[Coin, Map[Path, Int]]]

define hasCoin(map, acctID, c) (
    acctID in map && c in map[acctID]
)

define balancesPositive(map) (
    (forall acctID: AccountID, c: Coin, p: Path :: 
        (hasCoin(map, acctID, c) && p in map[acctID][c]) ==> map[acctID][c][p] >= 0)
)

define balanceOfM(map, acctID, c) (
    sumValues(map[acctID][c])
)

function balanceOf(map: Map[AccountID, Map[Coin, Map[Path, Int]]], acctID: AccountID, c: Coin): Int
    requires balancesPositive(map)
 {
    hasCoin(map, acctID, c) ? balanceOfM(map, acctID, c) : 0
 }

domain AccountID {
    function toResourceHolder(bank: Ref, acctId: AccountID): ResourceHolder

    axiom injective {
        forall c1: Ref, c2: Ref,  a1 : AccountID, a2: AccountID :: (a1 != a2 ||  c1 != c2) ==> 
            toResourceHolder(c1, a1) != toResourceHolder(c2, a2)
    }
}

domain Path {
    function startsWith(path: Path, port: Port, channel: ChannelEnd): Bool

    axiom startsWithUniq {
        forall p: Path, port1: Port, port2: Port, ch1: ChannelEnd, ch2: ChannelEnd ::
            startsWith(p, port1, ch1) && (port1 != port2 || ch1 != ch2) ==> !startsWith(
                p, port2, ch2
            )
    }
}

function prependPrefix(path: Path, port: Port, channel: ChannelEnd): Path
  ensures(startsWith(result, port, channel))


function dropPrefix(path: Path, port: Port, channel: ChannelEnd): Path
  requires(startsWith(path, port, channel))

// Monomorphised
function sumValues(map: Map[Path, Int]): Int
    requires forall p : Path :: p in map ==> map[p] >= 0
    ensures forall p : Path :: p in map ==> map[p] <= result
    ensures map == Map() ==> result == 0

domain Coin {
    function toResource(coin: Coin): Resource

    axiom toResourceInjective {
        forall c1 : Coin, c2: Coin :: c1 != c2 ==> toResource(c1) != toResource(c2)
    }

    function mkCoin(id: Int): Coin
}


define updateBalance(bank, acctID, path, coin, amt){
    if (!(acctID in bank.bankBalances)) {
        bank.bankBalances := bank.bankBalances[acctID := Map()]
    }
    var coinMap : Map[Coin, Map[Path, Int]]:= bank.bankBalances[acctID]
    if (!(coin in coinMap)) {
        coinMap := coinMap[coin := Map()]
    }
    var pathMap : Map[Path, Int] := coinMap[coin]
    if (!(path in pathMap)) {
       pathMap := pathMap[path := 0]
    }
    pathMap := pathMap[path := pathMap[path] + amt]
    assume sumValues(pathMap) == sumValues(coinMap[coin]) + amt
    coinMap := coinMap[coin := pathMap]
    bank.bankBalances := bank.bankBalances[acctID := coinMap]
}

define bankInvariants(bank) (
    balancesPositive(bank.bankBalances) &&
    (forall acctID : AccountID, c : Coin ::
            balanceOf(bank.bankBalances, acctID, c) == 
            ghostBalance(toResourceHolder(bank, acctID), toResource(c)).resourceAmount
    )
)
define bankResourcesAcc(bank) (
    forall acctID: AccountID, c : Coin :: acc(ghostBalance(toResourceHolder(bank, acctID), toResource(c)).resourceAmount)
)

define Bank(bank) (
    acc(bank.bankBalances) && bankResourcesAcc(bank) && bankInvariants(bank)
)

method bankMintTokens(
    bank: Ref,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires Bank(bank)
    requires amt >= 0
    requires acc(CanMint(toResourceHolder(bank,to), toResource(coin)), amt / 1)
    ensures Bank(bank)
    ensures balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
{
    ghostMint(
        toResourceHolder(bank,to),
        toResource(coin),
        amt
    )
    updateBalance(bank, to, path, coin, amt)
}

method bankBurnTokens(
    bank: Ref,
    from: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires Bank(bank)
    requires amt >= 0
    requires canBurn(toResourceHolder(bank, from), toResource(coin), amt)
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
{
    if(hasCoin(bank.bankBalances, from, coin) && 
       path in bank.bankBalances[from][coin] && 
       bank.bankBalances[from][coin][path] >= amt) {
        ghostMint(
            toResourceHolder(bank, from),
            toResource(coin),
            0 - amt
        )
        updateBalance(bank, from, path, coin, 0 - amt)
        success := true
    } else {
        success := false
    }
}

method bankTransferTokens(
    bank: Ref,
    from: AccountID,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires Bank(bank)
    requires amt >= 0
    requires canTransfer(
        toResourceHolder(bank, from), 
        toResourceHolder(bank, to), 
        toResource(coin), 
        amt
    )
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
    ensures success ==> balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
{
    if(from != to && hasCoin(bank.bankBalances, from, coin) && 
       path in bank.bankBalances[from][coin] && 
       bank.bankBalances[from][coin][path] >= amt) {
       ghostTransfer(
            toResourceHolder(bank, from),
            toResourceHolder(bank, to),
            toResource(coin),
            amt
        )
        updateBalance(bank, from, path, coin, (0 - amt))
        updateBalance(bank, to, path, coin, amt)
        success := true
    } else {
        success := false
    }
}

domain Port {

    function mkPort(id: Int): Port

}

domain ChannelEnd {
    function mkChannelEnd(id: Int): ChannelEnd
}

adt FungibleTokenPacketData {
    PacketData(
        path: Path,
        coin: Coin,
        sender: AccountID,
        receiver: AccountID,
        amount: Int
    )
}

adt Packet {
    _Packet(
        sourcePort: Port,
        sourceChannel: ChannelEnd,
        destPort: Port,
        destChannel: ChannelEnd,
        data: FungibleTokenPacketData
    )
}

function mkPacket(
  sourcePort: Port,
  sourceChannel: ChannelEnd,
  data: FungibleTokenPacketData
): Packet
  ensures result.sourcePort == sourcePort
  ensures result.sourceChannel == sourceChannel
  ensures result.data == data

adt FungibleTokenPacketAcknowledgement {
    Ack(
        success: Bool
    )
}

function escrowAddress(bank: Ref, channel: ChannelEnd): AccountID

method sendFungibleTokens(
    bank: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd
) returns (success: Bool, packet: Packet)
   requires Bank(bank)
   requires amount >= 0
   requires !startsWith(path, sourcePort, sourceChannel) ==> 
        canTransfer(
            toResourceHolder(bank, sender), 
            toResourceHolder(bank, escrowAddress(bank, sourceChannel)), 
            toResource(coin), 
            amount
        )
   requires startsWith(path, sourcePort, sourceChannel) ==> 
        canBurn(toResourceHolder(bank, sender), toResource(coin), amount)
   ensures Bank(bank)
   ensures !success ==> bank.bankBalances == old(bank.bankBalances)
   ensures success ==> (packet == mkPacket(sourcePort, sourceChannel, PacketData(path, coin, sender, receiver, amount)))
   ensures success ==> (balanceOf(bank.bankBalances, sender, coin) == old(balanceOf(bank.bankBalances, sender, coin)) - amount)
   ensures (success && !startsWith(path, sourcePort, sourceChannel)) ==> (
            balanceOf(bank.bankBalances, escrowAddress(bank, sourceChannel), coin) == 
        old(balanceOf(bank.bankBalances, escrowAddress(bank, sourceChannel), coin)) + amount)
{
    if(!startsWith(path, sourcePort, sourceChannel)) {
        success := bankTransferTokens(
            bank,
            sender,
            escrowAddress(bank, sourceChannel),
            path,
            coin,
            amount
        )
    } else {
        success := bankBurnTokens(
            bank,
            sender,
            path,
            coin,
            amount
        )
    }
    var data: FungibleTokenPacketData := PacketData(
        path,
        coin,
        sender,
        receiver,
        amount
    )
    packet := mkPacket(sourcePort, sourceChannel, data)
}

method refundTokens(
    bank: Ref,
    packet: Packet
) 
    requires Bank(bank)
    requires packet.data.amount >= 0
    requires !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canTransfer(
            toResourceHolder(bank, escrowAddress(bank, packet.sourceChannel)),
            toResourceHolder(bank, packet.data.sender),
            toResource(packet.data.coin), 
            packet.data.amount
        )
    requires startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canMint(toResourceHolder(bank, packet.data.sender), toResource(packet.data.coin), packet.data.amount)
    ensures Bank(bank)
{
    var success: Bool

    if(!startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.sourceChannel),
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount
        )

    }
}

method onRecvPacket(
    bank: Ref,
    packet: Packet
) returns (ack: FungibleTokenPacketAcknowledgement) 
    requires Bank(bank)
    requires packet.data.amount >= 0
    requires startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canTransfer(
            toResourceHolder(bank, escrowAddress(bank, packet.destChannel)),
            toResourceHolder(bank, packet.data.receiver),
            toResource(packet.data.coin),
            packet.data.amount
        )
    requires !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canMint(toResourceHolder(bank, packet.data.receiver), toResource(packet.data.coin), packet.data.amount)
    ensures Bank(bank)
    ensures ack.success ==> (balanceOf(bank.bankBalances, packet.data.receiver, packet.data.coin) == old(balanceOf(bank.bankBalances, packet.data.receiver, packet.data.coin)) + packet.data.amount)
    ensures (ack.success && startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> (
            balanceOf(bank.bankBalances, escrowAddress(bank, packet.destChannel), packet.data.coin) == 
        old(balanceOf(bank.bankBalances, escrowAddress(bank, packet.destChannel), packet.data.coin)) - packet.data.amount)
{
    var success: Bool
    if(startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.receiver,
            prependPrefix(packet.data.path, packet.destPort, packet.destChannel),
            packet.data.coin,
            packet.data.amount
        )
    }
    ack := Ack(success)
}

method onAcknowledgePacket(
    bank: Ref,
    ack: FungibleTokenPacketAcknowledgement,
    packet: Packet
) 
    requires Bank(bank)
    requires packet.data.amount >= 0
    requires (!ack.success && !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        canTransfer(
            toResourceHolder(bank, escrowAddress(bank, packet.sourceChannel)), 
            toResourceHolder(bank, packet.data.sender), 
            toResource(packet.data.coin), 
            packet.data.amount
        )
    requires (!ack.success && startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        canMint(toResourceHolder(bank, packet.data.sender), toResource(packet.data.coin), packet.data.amount)
    ensures Bank(bank)
    ensures ack.success ==> bank.bankBalances == old(bank.bankBalances)
{
    if(!ack.success) {
        refundTokens(bank, packet)
    } else {

    }

}

method roundTrip(
    bank1: Ref,
    bank2: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd,
    destPort: Port,
    destChannel: ChannelEnd
) 
    requires Bank(bank1)
    requires Bank(bank2)
    requires bank1 != bank2
    requires amount >= 0
    requires !startsWith(path, sourcePort, sourceChannel)
    requires canTransfer(
        toResourceHolder(bank1, sender), 
        toResourceHolder(bank1, escrowAddress(bank1, sourceChannel)), 
        toResource(coin), 
        amount
    )
    requires canMint(toResourceHolder(bank2, receiver), toResource(coin), amount)
    requires canBurn(toResourceHolder(bank2, receiver), toResource(coin), amount)
    requires canTransfer(
        toResourceHolder(bank1, escrowAddress(bank1, sourceChannel)), 
        toResourceHolder(bank1, sender), 
        toResource(coin), 
        amount)
    ensures Bank(bank1)
    ensures Bank(bank2)
    ensures balanceOf(bank1.bankBalances, sender, coin) == old(balanceOf(bank1.bankBalances, sender, coin))
    ensures balanceOf(bank1.bankBalances, escrowAddress(bank1, sourceChannel), coin) == old(balanceOf(bank1.bankBalances, escrowAddress(bank1, sourceChannel), coin))
    ensures balanceOf(bank2.bankBalances, receiver, coin) == old(balanceOf(bank2.bankBalances, receiver, coin))
{
    var success: Bool
    var packet: Packet

    success, packet := sendFungibleTokens(bank1, path, coin, amount, sender, receiver, sourcePort, sourceChannel)
    assume success
    assert balanceOf(bank1.bankBalances, sender, coin) == old(balanceOf(bank1.bankBalances, sender, coin)) - amount
    assume packet.destPort == destPort
    assume packet.destChannel == destChannel
    var ack: FungibleTokenPacketAcknowledgement 
    assert bankInvariants(bank2)
    ack := onRecvPacket(bank2, packet)
    assume ack.success
    onAcknowledgePacket(bank1, ack, packet)

    success, packet := sendFungibleTokens(
        bank2, 
        prependPrefix(path, destPort, destChannel), 
        coin, 
        amount, 
        receiver, 
        sender, 
        destPort, 
        destChannel
    )
    assume success
    assume packet.destChannel == sourceChannel
    ack := onRecvPacket(bank1, packet)
    assume ack.success
    onAcknowledgePacket(bank2, ack, packet)
}