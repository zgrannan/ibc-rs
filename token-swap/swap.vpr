// GHOST 

domain ResourceHolder {
    // Accounts 
    function ghostBalance(rh: ResourceHolder, resource: Resource): Ref

    axiom balanceInjective {
        forall owner1: ResourceHolder, owner2: ResourceHolder, resource1: Resource, resource2: Resource :: 
        owner1 != owner2 || resource1 != resource2 ==> ghostBalance(owner1, resource1) != ghostBalance(owner2, resource2)
    }

    function mkResourceHolder(id: Int): ResourceHolder

}

function total(resources: Set[ResourceHolder], resource: Resource): Int
    requires forall r : ResourceHolder :: acc(ghostBalance(r, resource).resourceAmount)

domain Resource {
    function mkResource(id: Int): Resource
}

domain ActionPerm {
    function canTransferOut(thePerm: ActionPerm, from: ResourceHolder, resource: Resource, amount: Int): Bool
    function canMint(thePerm: ActionPerm, to: ResourceHolder, resource: Resource, amount: Int): Bool
}

function canBurn(thePerm: ActionPerm, to: ResourceHolder, resource: Resource, amount: Int): Bool {
    canMint(thePerm, to, resource, 0 - amount)
}

// A permission to perform an action on a resource
field actionPerm: ActionPerm


// Field of returned ref from `balance`
field resourceAmount: Int

method ghostMint(
    to: ResourceHolder, 
    resource: Resource,
    amount: Int,
    permRef: Ref
) 
   requires acc(ghostBalance(to, resource).resourceAmount)
   requires acc(permRef.actionPerm)
   requires(ghostBalance(to, resource).resourceAmount + amount >= 0)
   ensures acc(ghostBalance(to, resource).resourceAmount)
   ensures ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount
{
    ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
}

method ghostTransfer(
    from: ResourceHolder, 
    to: ResourceHolder, 
    resource: Resource,
    amount: Int,
    permRef: Ref
)
   requires acc(ghostBalance(from, resource).resourceAmount)
   requires acc(ghostBalance(to, resource).resourceAmount)
   requires acc(permRef.actionPerm)
   requires(amount >= 0)
   requires(ghostBalance(from, resource).resourceAmount >= amount)
   requires canTransferOut(permRef.actionPerm, from, resource, amount)
   ensures acc(ghostBalance(from, resource).resourceAmount)
   ensures acc(ghostBalance(to, resource).resourceAmount)
   ensures ghostBalance(from, resource).resourceAmount == old(ghostBalance(from, resource).resourceAmount) - amount
   ensures ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount

   // Sanity check: total sum of resource unchanged
   ensures (ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount) ==
           old(ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount)

{
    ghostBalance(from, resource).resourceAmount := ghostBalance(from, resource).resourceAmount - amount
    ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
}


// NONGHOST

field bankBalances: Map[AccountID, Map[Coin, Map[Path, Int]]]

define hasCoin(map, acctID, c) (
    acctID in map && c in map[acctID]
)

define balancesPositive(map) (
    (forall acctID: AccountID, c: Coin, p: Path :: 
        (hasCoin(map, acctID, c) && p in map[acctID][c]) ==> map[acctID][c][p] >= 0)
)

define balanceOfM(map, acctID, c) (
    sumValues(map[acctID][c])
)

function balanceOf(map: Map[AccountID, Map[Coin, Map[Path, Int]]], acctID: AccountID, c: Coin): Int
    requires balancesPositive(map)
 {
    hasCoin(map, acctID, c) ? balanceOfM(map, acctID, c) : 0
 }

domain AccountID {
    function toResourceHolder(bank: Ref, acctId: AccountID): ResourceHolder

    axiom injective {
        forall c1: Ref, c2: Ref,  a1 : AccountID, a2: AccountID :: a1 != a2 ||  c1 != c2 ==> 
            toResourceHolder(c1, a1) != toResourceHolder(c2, a2)
    }
}

domain Path {
    function startsWith(path: Path, port: Port, channel: ChannelEnd): Bool

    axiom startsWithUniq {
        forall p: Path, port1: Port, port2: Port, ch1: ChannelEnd, ch2: ChannelEnd ::
            startsWith(p, port1, ch1) && (port1 != port2 || ch1 != ch2) ==> !startsWith(
                p, port2, ch2
            )
    }
}

function prependPrefix(path: Path, port: Port, channel: ChannelEnd): Path
  ensures(startsWith(result, port, channel))


function dropPrefix(path: Path, port: Port, channel: ChannelEnd): Path
  requires(startsWith(path, port, channel))

// Monomorphised
function sumValues(map: Map[Path, Int]): Int
    requires forall p : Path :: p in map ==> map[p] >= 0
    ensures forall p : Path :: p in map ==> map[p] <= result
    ensures map == Map() ==> result == 0

domain Coin {
    function toResource(coin: Coin): Resource

    axiom toResourceInjective {
        forall c1 : Coin, c2: Coin :: c1 != c2 ==> toResource(c1) != toResource(c2)
    }

    function mkCoin(id: Int): Coin
}


define updateBalance(bank, acctID, path, coin, amt){
    if (!(acctID in bank.bankBalances)) {
        bank.bankBalances := bank.bankBalances[acctID := Map()]
    }
    var coinMap : Map[Coin, Map[Path, Int]]:= bank.bankBalances[acctID]
    if (!(coin in coinMap)) {
        coinMap := coinMap[coin := Map()]
    }
    var pathMap : Map[Path, Int] := coinMap[coin]
    if (!(path in pathMap)) {
       pathMap := pathMap[path := 0]
    }
    pathMap := pathMap[path := pathMap[path] + amt]
    assume sumValues(pathMap) == sumValues(coinMap[coin]) + amt
    coinMap := coinMap[coin := pathMap]
    bank.bankBalances := bank.bankBalances[acctID := coinMap]
}

define bankInvariants(bank) (
    balancesPositive(bank.bankBalances) &&
    (forall acctID : AccountID, c : Coin ::
            balanceOf(bank.bankBalances, acctID, c) == 
            ghostBalance(toResourceHolder(bank, acctID), toResource(c)).resourceAmount
    )
)
define bankResourcesAcc(bank) (
    forall acctID: AccountID, c : Coin :: acc(ghostBalance(toResourceHolder(bank, acctID), toResource(c)).resourceAmount)
)

define Bank(bank) (
    acc(bank.bankBalances) && bankResourcesAcc(bank) && bankInvariants(bank)
)

method bankMintTokens(
    bank: Ref,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int,
    ghostPerm: Ref
) returns (success: Bool)
    requires Bank(bank)
    requires acc(ghostPerm.actionPerm)
    requires amt >= 0
    requires canMint(ghostPerm.actionPerm, toResourceHolder(bank,to), toResource(coin), amt)
    ensures Bank(bank)
    ensures balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
{
    ghostMint(
        toResourceHolder(bank,to),
        toResource(coin),
        amt,
        ghostPerm
    )
    updateBalance(bank, to, path, coin, amt)
}

method bankBurnTokens(
    bank: Ref,
    from: AccountID,
    path: Path,
    coin: Coin,
    amt: Int,
    ghostPerm: Ref
) returns (success: Bool)
    requires Bank(bank)
    requires acc(ghostPerm.actionPerm)
    requires canMint(ghostPerm.actionPerm, toResourceHolder(bank, from), toResource(coin), 0 - amt)
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
{
    if(hasCoin(bank.bankBalances, from, coin) && 
       path in bank.bankBalances[from][coin] && 
       bank.bankBalances[from][coin][path] >= amt) {
        ghostMint(
            toResourceHolder(bank, from),
            toResource(coin),
            0 - amt,
            ghostPerm
        )
        updateBalance(bank, from, path, coin, 0 - amt)
        success := true
    } else {
        success := false
    }
}

method bankTransferTokens(
    bank: Ref,
    from: AccountID,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int,
    ghostPerm: Ref
) returns (success: Bool)
    requires Bank(bank)
    requires amt >= 0
    requires acc(ghostPerm.actionPerm)
    requires canTransferOut(ghostPerm.actionPerm, toResourceHolder(bank, from), toResource(coin), amt)
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
    ensures success ==> balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
{
    if(from != to && hasCoin(bank.bankBalances, from, coin) && 
       path in bank.bankBalances[from][coin] && 
       bank.bankBalances[from][coin][path] >= amt) {
       ghostTransfer(
            toResourceHolder(bank, from),
            toResourceHolder(bank, to),
            toResource(coin),
            amt,
            ghostPerm
        )
        updateBalance(bank, from, path, coin, (0 - amt))
        updateBalance(bank, to, path, coin, amt)
        success := true
    } else {
        success := false
    }
}

domain Port {

    function mkPort(id: Int): Port

}

domain ChannelEnd {
    function mkChannelEnd(id: Int): ChannelEnd
}

adt FungibleTokenPacketData {
    PacketData(
        path: Path,
        coin: Coin,
        sender: AccountID,
        receiver: AccountID,
        amount: Int
    )
}

adt Packet {
    _Packet(
        sourcePort: Port,
        sourceChannel: ChannelEnd,
        destPort: Port,
        destChannel: ChannelEnd,
        data: FungibleTokenPacketData
    )
}

function mkPacket(
  sourcePort: Port,
  sourceChannel: ChannelEnd,
  data: FungibleTokenPacketData
): Packet
  ensures result.sourcePort == sourcePort
  ensures result.sourceChannel == sourceChannel
  ensures result.data == data

adt FungibleTokenPacketAcknowledgement {
    Ack(
        success: Bool
    )
}

function escrowAddress(bank: Ref, channel: ChannelEnd): AccountID

method sendFungibleTokens(
    bank: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd,
    ghostPerm: Ref
) returns (success: Bool, packet: Packet)
   requires Bank(bank)
   requires amount >= 0
   requires acc(ghostPerm.actionPerm)
   requires !startsWith(path, sourcePort, sourceChannel) ==> 
        canTransferOut(ghostPerm.actionPerm, toResourceHolder(bank, sender), toResource(coin), amount)
   requires startsWith(path, sourcePort, sourceChannel) ==> 
        canBurn(ghostPerm.actionPerm, toResourceHolder(bank, sender), toResource(coin), amount)
   ensures Bank(bank)
   ensures !success ==> bank.bankBalances == old(bank.bankBalances)
   ensures success ==> (packet == mkPacket(sourcePort, sourceChannel, PacketData(path, coin, sender, receiver, amount)))
{
    if(!startsWith(path, sourcePort, sourceChannel)) {
        success := bankTransferTokens(
            bank,
            sender,
            escrowAddress(bank, sourceChannel),
            path,
            coin,
            amount,
            ghostPerm
        )
    } else {
        success := bankBurnTokens(
            bank,
            sender,
            path,
            coin,
            amount,
            ghostPerm
        )
    }
    var data: FungibleTokenPacketData := PacketData(
        path,
        coin,
        sender,
        receiver,
        amount
    )
    packet := mkPacket(sourcePort, sourceChannel, data)
}

method refundTokens(
    bank: Ref,
    packet: Packet,
    ghostPerm: Ref
) 
    requires Bank(bank)
    requires packet.data.amount >= 0
    requires acc(ghostPerm.actionPerm)
    requires !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canTransferOut(ghostPerm.actionPerm, toResourceHolder(bank, escrowAddress(bank, packet.sourceChannel)), toResource(packet.data.coin), packet.data.amount)
    requires startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canMint(ghostPerm.actionPerm, toResourceHolder(bank, packet.data.sender), toResource(packet.data.coin), packet.data.amount)
    ensures Bank(bank)
{
    var success: Bool

    if(!startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.sourceChannel),
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount,
            ghostPerm
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount,
            ghostPerm
        )

    }
}

method onRecvPacket(
    bank: Ref,
    packet: Packet,
    ghostPerm: Ref
) returns (ack: FungibleTokenPacketAcknowledgement) 
    requires Bank(bank)
    requires packet.data.amount >= 0
    requires acc(ghostPerm.actionPerm)
    requires startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canTransferOut(ghostPerm.actionPerm, toResourceHolder(bank, escrowAddress(bank, packet.destChannel)), toResource(packet.data.coin), packet.data.amount)
    requires !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canMint(ghostPerm.actionPerm, toResourceHolder(bank, packet.data.receiver), toResource(packet.data.coin), packet.data.amount)
    ensures Bank(bank)
{
    var success: Bool
    if(startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount,
            ghostPerm
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.receiver,
            prependPrefix(packet.data.path, packet.destPort, packet.destChannel),
            packet.data.coin,
            packet.data.amount,
            ghostPerm
        )
    }
    ack := Ack(success)
}

method onAcknowledgePacket(
    bank: Ref,
    ack: FungibleTokenPacketAcknowledgement,
    packet: Packet,
    ghostPerm: Ref
) 
    requires Bank(bank)
    requires packet.data.amount >= 0
    requires acc(ghostPerm.actionPerm)
    requires (!ack.success && !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        canTransferOut(ghostPerm.actionPerm, toResourceHolder(bank, escrowAddress(bank, packet.sourceChannel)), toResource(packet.data.coin), packet.data.amount)
    requires (!ack.success && startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        canMint(ghostPerm.actionPerm, toResourceHolder(bank, packet.data.sender), toResource(packet.data.coin), packet.data.amount)
    ensures Bank(bank)
{
    if(!ack.success) {
        refundTokens(bank, packet, ghostPerm)
    } else {

    }

}

method roundTrip(
    bank1: Ref,
    bank2: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd,
    destPort: Port,
    destChannel: ChannelEnd,
    ghostPerm1: Ref,
    ghostPerm2: Ref,
    ghostPerm3: Ref,
    ghostPerm4: Ref,
    ghostPerm5: Ref,
    ghostPerm6: Ref
) 
    requires Bank(bank1)
    requires Bank(bank2)
    requires bank1 != bank2
    requires amount >= 0
    requires !startsWith(path, sourcePort, sourceChannel)
    requires acc(ghostPerm1.actionPerm)
    requires acc(ghostPerm2.actionPerm)
    requires acc(ghostPerm3.actionPerm)
    requires acc(ghostPerm4.actionPerm)
    requires acc(ghostPerm5.actionPerm)
    requires acc(ghostPerm6.actionPerm)
    requires canTransferOut(ghostPerm1.actionPerm, toResourceHolder(bank1, sender), toResource(coin), amount)
    requires canMint(ghostPerm2.actionPerm, toResourceHolder(bank2, receiver), toResource(coin), amount)
    requires canBurn(ghostPerm4.actionPerm, toResourceHolder(bank2, receiver), toResource(coin), amount)
    requires canTransferOut(ghostPerm5.actionPerm, toResourceHolder(bank1, escrowAddress(bank1, sourceChannel)), toResource(coin), amount)
    requires sourceChannel != destChannel
    ensures Bank(bank1)
    ensures Bank(bank2)
    ensures ghostBalance(toResourceHolder(bank1, sender), toResource(coin)).resourceAmount == old(ghostBalance(toResourceHolder(bank1, sender), toResource(coin)).resourceAmount)
    ensures ghostBalance(toResourceHolder(bank2, receiver), toResource(coin)).resourceAmount == old(ghostBalance(toResourceHolder(bank2, receiver), toResource(coin)).resourceAmount)
    ensures bank1.bankBalances == old(bank1.bankBalances)
{
    var success: Bool
    var packet: Packet

    success, packet := sendFungibleTokens(bank1, path, coin, amount, sender, receiver, sourcePort, sourceChannel, ghostPerm1)
    assume packet.destPort == destPort
    assume packet.destChannel == destChannel
    var ack: FungibleTokenPacketAcknowledgement 
    assume success
    assert bankInvariants(bank2)
    ack := onRecvPacket(bank2, packet, ghostPerm2)
    assume ack.success
    onAcknowledgePacket(bank1, ack, packet, ghostPerm3)

    success, packet := sendFungibleTokens(
        bank2, 
        prependPrefix(path, destPort, destChannel), 
        coin, 
        amount, 
        receiver, 
        sender, 
        destPort, 
        destChannel, 
        ghostPerm4
    )
    assume success
    assert startsWith(packet.data.path, destPort, destChannel)
    assert !startsWith(packet.data.path, sourcePort, sourceChannel)
    assume packet.destChannel == sourceChannel
    ack := onRecvPacket(bank1, packet, ghostPerm5)
    assume ack.success
    onAcknowledgePacket(bank2, ack, packet, ghostPerm6)
}