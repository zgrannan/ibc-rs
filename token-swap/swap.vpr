// GHOST 

domain ResourceHolder {
    // Accounts 
    function ghostBalance(rh: ResourceHolder, resource: Resource): Ref

    axiom balanceInjective {
        forall owner1: ResourceHolder, owner2: ResourceHolder, resource1: Resource, resource2: Resource :: 
        owner1 != owner2 || resource1 != resource2 ==> ghostBalance(owner1, resource1) != ghostBalance(owner2, resource2)
    }

}

function total(resources: Set[ResourceHolder], resource: Resource): Int
    requires forall r : ResourceHolder :: acc(ghostBalance(r, resource).resourceAmount)

domain Resource {

}

domain ActionPerm {
    function canTransferOut(thePerm: ActionPerm, from: ResourceHolder, resource: Resource, amount: Int): Bool
    function canMint(thePerm: ActionPerm, to: ResourceHolder, resource: Resource, amount: Int): Bool
}

function canBurn(thePerm: ActionPerm, to: ResourceHolder, resource: Resource, amount: Int): Bool {
    canMint(thePerm, to, resource, 0 - amount)
}

// A permission to perform an action on a resource
field actionPerm: ActionPerm


// Field of returned ref from `balance`
field resourceAmount: Int

method ghostMint(
    to: ResourceHolder, 
    resource: Resource,
    amount: Int,
    permRef: Ref
) 
   requires acc(ghostBalance(to, resource).resourceAmount)
   requires acc(permRef.actionPerm)
   requires(ghostBalance(to, resource).resourceAmount + amount >= 0)
   ensures acc(ghostBalance(to, resource).resourceAmount)
   ensures ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount
{
    ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
}

method ghostTransfer(
    from: ResourceHolder, 
    to: ResourceHolder, 
    resource: Resource,
    amount: Int,
    permRef: Ref
)
   requires acc(ghostBalance(from, resource).resourceAmount)
   requires acc(ghostBalance(to, resource).resourceAmount)
   requires acc(permRef.actionPerm)
   requires(amount >= 0)
   requires(ghostBalance(from, resource).resourceAmount >= amount)
   requires canTransferOut(permRef.actionPerm, from, resource, amount)
   ensures acc(ghostBalance(from, resource).resourceAmount)
   ensures acc(ghostBalance(to, resource).resourceAmount)
   ensures ghostBalance(from, resource).resourceAmount == old(ghostBalance(from, resource).resourceAmount) - amount
   ensures ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount

   // Sanity check: total sum of resource unchanged
   ensures (ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount) ==
           old(ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount)

{
    ghostBalance(from, resource).resourceAmount := ghostBalance(from, resource).resourceAmount - amount
    ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
}


// NONGHOST

field bankBalances: Map[AccountID, Map[Coin, Map[Prefix, Int]]]

define hasCoin(map, acctID, c) (
    acctID in map && c in map[acctID]
)

define balancesPositive(map) (
    (forall acctID: AccountID, c: Coin, p: Prefix :: 
        (hasCoin(map, acctID, c) && p in map[acctID][c]) ==> map[acctID][c][p] >= 0)
)

define balanceOfM(map, acctID, c) (
    sumValues(map[acctID][c])
)

function balanceOf(map: Map[AccountID, Map[Coin, Map[Prefix, Int]]], acctID: AccountID, c: Coin): Int
    requires balancesPositive(map)
 {
    hasCoin(map, acctID, c) ? balanceOfM(map, acctID, c) : 0
 }

domain AccountID {
    function toResourceHolder(acctId: AccountID): ResourceHolder

    axiom injective {
        forall a1 : AccountID, a2: AccountID :: a1 != a2 ==> toResourceHolder(a1) != toResourceHolder(a2)
    }
}

domain Prefix {
    function startsWith(prefix: Prefix, port: Port, channel: Channel): Bool
}

// Monomorphised
function sumValues(map: Map[Prefix, Int]): Int
    requires forall p : Prefix :: p in map ==> map[p] >= 0
    ensures forall p : Prefix :: p in map ==> map[p] <= result
    ensures map == Map() ==> result == 0

domain Coin {
    function toResource(coin: Coin): Resource

    axiom toResourceInjective {
        forall c1 : Coin, c2: Coin :: c1 != c2 ==> toResource(c1) != toResource(c2)
    }

    function mkCoin(id: Int): Coin
}


define updateBalance(bank, acctID, prefix, coin, amt){
    if (!(acctID in bank.bankBalances)) {
        bank.bankBalances := bank.bankBalances[acctID := Map()]
    }
    var coinMap : Map[Coin, Map[Prefix, Int]]:= bank.bankBalances[acctID]
    if (!(coin in coinMap)) {
        coinMap := coinMap[coin := Map()]
    }
    var prefixMap : Map[Prefix, Int] := coinMap[coin]
    if (!(prefix in prefixMap)) {
       prefixMap := prefixMap[prefix := 0]
    }
    prefixMap := prefixMap[prefix := prefixMap[prefix] + amt]
    assume sumValues(prefixMap) == sumValues(coinMap[coin]) + amt
    coinMap := coinMap[coin := prefixMap]
    bank.bankBalances := bank.bankBalances[acctID := coinMap]
}

define bankInvariants(bankBalances) (
    forall r : ResourceHolder,c : Coin :: acc(ghostBalance(r, toResource(c)).resourceAmount) &&
    balancesPositive(bankBalances) &&
    (forall acctID : AccountID, c : Coin ::
            balanceOf(bankBalances, acctID, c) == 
            ghostBalance(toResourceHolder(acctID), toResource(c)).resourceAmount
    )
)

define Bank(bank) (
    acc(bank.bankBalances) && bankInvariants(bank.bankBalances)
)

method bankMintTokens(
    bank: Ref,
    to: AccountID,
    prefix: Prefix,
    coin: Coin,
    amt: Int,
    ghostPerm: Ref
) 
    requires Bank(bank)
    requires acc(ghostPerm.actionPerm)
    requires amt >= 0
    requires canMint(ghostPerm.actionPerm, toResourceHolder(to), toResource(coin), amt)
    ensures Bank(bank)
    ensures balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
{
    ghostMint(
        toResourceHolder(to),
        toResource(coin),
        amt,
        ghostPerm
    )
    updateBalance(bank, to, prefix, coin, amt)
}

method bankBurnTokens(
    bank: Ref,
    from: AccountID,
    prefix: Prefix,
    coin: Coin,
    amt: Int,
    ghostPerm: Ref
) returns (success: Bool)
    requires Bank(bank)
    requires acc(ghostPerm.actionPerm)
    requires canMint(ghostPerm.actionPerm, toResourceHolder(from), toResource(coin), 0 - amt)
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
{
    if(hasCoin(bank.bankBalances, from, coin) && 
       prefix in bank.bankBalances[from][coin] && 
       bank.bankBalances[from][coin][prefix] >= amt) {
        ghostMint(
            toResourceHolder(from),
            toResource(coin),
            0 - amt,
            ghostPerm
        )
        updateBalance(bank, from, prefix, coin, 0 - amt)
        success := true
    } else {
        success := false
    }
}

method bankTransferTokens(
    bank: Ref,
    from: AccountID,
    to: AccountID,
    prefix: Prefix,
    coin: Coin,
    amt: Int,
    ghostPerm: Ref
) returns (success: Bool)
    requires Bank(bank)
    requires amt >= 0
    requires acc(ghostPerm.actionPerm)
    requires canTransferOut(ghostPerm.actionPerm, toResourceHolder(from), toResource(coin), amt)
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
    ensures success ==> balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
{
    if(from != to && hasCoin(bank.bankBalances, from, coin) && 
       prefix in bank.bankBalances[from][coin] && 
       bank.bankBalances[from][coin][prefix] >= amt) {
       ghostTransfer(
            toResourceHolder(from),
            toResourceHolder(to),
            toResource(coin),
            amt,
            ghostPerm
        )
        updateBalance(bank, from, prefix, coin, (0 - amt))
        updateBalance(bank, to, prefix, coin, amt)
        success := true
    } else {
        success := false
    }
}

domain Port {

}

domain Channel {

}

function escrowAddress(bank: Ref, channel: Channel): AccountID

method sendFungibleTokens(
    bank: Ref,
    prefix: Prefix,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: Channel,
    ghostPerm: Ref
) returns (success: Bool)
    requires Bank(bank)
    requires amount >= 0
    requires acc(ghostPerm.actionPerm)
    requires !startsWith(prefix, sourcePort, sourceChannel) ==> 
        canTransferOut(ghostPerm.actionPerm, toResourceHolder(sender), toResource(coin), amount)
    requires startsWith(prefix, sourcePort, sourceChannel) ==> 
        canBurn(ghostPerm.actionPerm, toResourceHolder(sender), toResource(coin), amount)
    ensures Bank(bank)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
{
    if(!startsWith(prefix, sourcePort, sourceChannel)) {
        success := bankTransferTokens(
            bank,
            sender,
            escrowAddress(bank, sourceChannel),
            prefix,
            coin,
            amount,
            ghostPerm
        )
    } else {
        success := bankBurnTokens(
            bank,
            sender,
            prefix,
            coin,
            amount,
            ghostPerm
        )
    }
}

method onRecvPacket(
    bank: Ref,
    prefix: Prefix,
    sourcePort: Port,
    sourceChannel: Channel,
    destChannel: Channel,
    coin: Coin,
    amt: Int,
    receiver: AccountID,
    ghostPerm: Ref
) returns (success: Bool) 
    requires Bank(bank)
    requires amt >= 0
    requires acc(ghostPerm.actionPerm)
    requires startsWith(prefix, sourcePort, sourceChannel) ==> 
        canTransferOut(ghostPerm.actionPerm, toResourceHolder(escrowAddress(bank, destChannel)), toResource(coin), amt)
    // requires startsWith(prefix, sourcePort, sourceChannel) ==> 
    //     canBurn(ghostPerm.actionPerm, toResourceHolder(sender), toResource(coin), amount)
    ensures Bank(bank)
{
    if(startsWith(prefix, sourcePort, sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, destChannel),
            receiver,
            prefix,
            coin,
            amt,
            ghostPerm
        )
    } else {

    }
}