// GHOST 

domain ResourceHolder {
    // Accounts 
    function balance(rh: ResourceHolder, resource: Resource): Ref

    axiom balanceInjective {
        forall owner1: ResourceHolder, owner2: ResourceHolder, resource1: Resource, resource2: Resource :: 
        owner1 != owner2 || resource1 != resource2 ==> balance(owner1, resource1) != balance(owner2, resource2)
    }

}

function total(resources: Set[ResourceHolder], resource: Resource): Int
    requires forall r : ResourceHolder :: acc(balance(r, resource).resourceAmount)

function ghostToMap(resources: Set[ResourceHolder]): Map[ResourceHolder, Map[Resource, Int]]
    requires forall rh : ResourceHolder, resource: Resource :: acc(balance(rh, resource).resourceAmount)
    ensures forall rh : ResourceHolder :: rh in resources ==> rh in result
    ensures forall rh : ResourceHolder, res: Resource :: (rh in result && res in result[rh]) ==> 
        result[rh][res] == balance(rh, res).resourceAmount

domain Resource {

}

domain ActionPerm {
    function canTransferOut(thePerm: ActionPerm, from: ResourceHolder, resource: Resource, amount: Int): Bool
}

// A permission to perform an action on a resource
field actionPerm: ActionPerm


// Field of returned ref from `balance`
field resourceAmount: Int

method assumePermission(from: ResourceHolder, resource: Resource, amt: Int) returns (permRef: Ref)
  ensures acc(permRef.actionPerm)
  ensures canTransferOut(permRef.actionPerm, from, resource, amt)

method ghostTransfer(
    from: ResourceHolder, 
    to: ResourceHolder, 
    resource: Resource,
    amount: Int,
    permRef: Ref
)
   requires acc(balance(from, resource).resourceAmount)
   requires acc(balance(to, resource).resourceAmount)
   requires acc(permRef.actionPerm)
   requires(amount >= 0)
   requires(balance(from, resource).resourceAmount >= amount)
   requires canTransferOut(permRef.actionPerm, from, resource, amount)
   ensures acc(balance(from, resource).resourceAmount)
   ensures acc(balance(to, resource).resourceAmount)
   ensures balance(from, resource).resourceAmount == old(balance(from, resource).resourceAmount) - amount
   ensures balance(to, resource).resourceAmount == old(balance(to, resource).resourceAmount) + amount

   // Sanity check: total sum of resource unchanged
   ensures (balance(from, resource).resourceAmount + balance(to, resource).resourceAmount) ==
           old(balance(from, resource).resourceAmount + balance(to, resource).resourceAmount)

{
    balance(from, resource).resourceAmount := balance(from, resource).resourceAmount - amount
    balance(to, resource).resourceAmount := balance(to, resource).resourceAmount + amount
}

// Monomorphised
function sumValues(map: Map[Prefix, Int]): Int
    requires forall p : Prefix :: p in map ==> map[p] >= 0
    ensures forall p : Prefix :: p in map ==> map[p] <= result

// NONGHOST

domain ChainID {
    function chain1() : ChainID
    function chain2() : ChainID
    axiom {
        chain1() != chain2()
    }

}
field bankBalances: Map[AccountID, Map[Coin, Map[Prefix, Int]]]

function realToMap(map: Map[AccountID, Map[Coin, Map[Prefix, Int]]]): Map[ResourceHolder, Map[Resource, Int]]
    ensures (
        forall accountID : AccountID, c : Coin :: (accountID in map && c in map[accountID]) ==> 
        (forall prefix : Prefix :: prefix in map[accountID][c] ==> map[accountID][c][prefix] >= 0) &&
        (toResourceHolder(chain1(), accountID) in result && 
        toResource(c) in result[toResourceHolder(chain1(), accountID)] &&
        result[toResourceHolder(chain1(), accountID)][toResource(c)] == sumValues(map[accountID][c]))
    )
    // ensures (
    //     forall accountID : AccountID :: accountID in map ==> toResourceHolder(chain1(), accountID) in result
    // )


domain AccountID {
    function toResourceHolder(chainID : ChainID, acctId: AccountID): ResourceHolder

    axiom {
        forall c1 : ChainID, c2 : ChainID, a1 : AccountID, a2: AccountID :: c1 != c2 || a1 != a2 ==> toResourceHolder(c1, a1) != toResourceHolder(c2, a2)
    }
}

domain Prefix {

}

domain Coin {
    function toResource(coin: Coin): Resource
}

define updateBalance(bank, acctID, prefix, coin, amt){
    var coinMap : Map[Coin, Map[Prefix, Int]]:= bank.bankBalances[acctID]
    var prefixMap : Map[Prefix, Int] := coinMap[coin]
    prefixMap := prefixMap[prefix := prefixMap[prefix] + amt]
    coinMap := coinMap[coin := prefixMap]
    bank.bankBalances := bank.bankBalances[acctID := coinMap]
}

method doTransfer(
    ghostAccounts: Set[ResourceHolder],
    bank: Ref,
    from: AccountID,
    to: AccountID,
    prefix: Prefix,
    coin: Coin,
    amt: Int
) 
    requires forall r : ResourceHolder :: acc(balance(r, toResource(coin)).resourceAmount)
    // requires acc(balance(toResourceHolder(to), toResource(coin)).resourceAmount)
    requires acc(bank.bankBalances)
    requires from in bank.bankBalances
    requires coin in bank.bankBalances[from]
    requires prefix in bank.bankBalances[from][coin]
    requires to in bank.bankBalances
    requires coin in bank.bankBalances[to]
    requires prefix in bank.bankBalances[to][coin]
    requires toResourceHolder(chain1(), from) in ghostAccounts
    requires realToMap(bank.bankBalances) == ghostToMap(ghostAccounts)
    requires (forall p : Prefix :: p in bank.bankBalances[from][coin] ==> bank.bankBalances[from][coin][p] >= 0)
    requires amt >= 0
    ensures acc(bank.bankBalances)
    ensures forall r : ResourceHolder :: acc(balance(r, toResource(coin)).resourceAmount)
    ensures realToMap(bank.bankBalances) == ghostToMap(ghostAccounts)
    // ensures(total(ghostAccounts, toResource(coin)) == old(total(ghostAccounts, toResource(coin))))
{
    var permRef: Ref 
    permRef := assumePermission(toResourceHolder(chain1(), from), toResource(coin), amt)
    assert acc(balance(toResourceHolder(chain2(), to), toResource(coin)).resourceAmount)
    if(bank.bankBalances[from][coin][prefix] >= amt) {
        assert sumValues(bank.bankBalances[from][coin]) >= amt
        ghostTransfer(
            toResourceHolder(chain1(), from),
            toResourceHolder(chain2(), to),
            toResource(coin),
            amt,
            permRef
        )
        updateBalance(bank, from, prefix, coin, (0 - amt))
        updateBalance(bank, to, prefix, coin, amt)
    }
    // var fromCoinBalance: Map[Prefix, Int] := bank.bankBalances[from][coin]
    // fromCoinBalance := fromCoinBalance[prefix := (fromCoinBalance[prefix] - amt)]
    // var toCoinBalance: Map[Prefix, Int] := bank.bankBalances[to][coin]
    // toCoinBalance := toCoinBalance[prefix := (toCoinBalance[prefix] + amt)]
    // var newFrom : Map[Coin, Map[Prefix, Int]] := bank.bankBalances[from]
    // newFrom := newFrom[c]
    // bank.bankBalances := bank.bankBalances[from := newFrom]

}