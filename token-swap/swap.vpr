// GHOST 

domain ResourceHolder {
    // Accounts 

    // function ghostBalance(rh: ResourceHolder, resource: Resource): Ref

    // axiom balanceInjective {
    //     forall owner1: ResourceHolder, owner2: ResourceHolder, resource1: Resource, resource2: Resource :: 
    //     owner1 != owner2 || resource1 != resource2 ==> ghostBalance(owner1, resource1) != ghostBalance(owner2, resource2)
    // }

    function mkResourceHolder(id: Int): ResourceHolder

}

domain Resource {
    function mkResource(id: Int): Resource
}

predicate Owns(holder: ResourceHolder, resource: Resource)
predicate CanTransfer(from: ResourceHolder, to: ResourceHolder, resource: Resource)
predicate CanMint(to: ResourceHolder, resource: Resource)
predicate CanBurn(to: ResourceHolder, resource: Resource)

define canTransfer(from, to, resource, amt) (
    acc(CanTransfer(from, to, resource), amt / 1)
)

define canMint(to, resource, amt) (
    acc(CanMint(to, resource), amt / 1)
)

define canBurn(to, resource, amount) (
    acc(CanBurn(to, resource), amount / 1)
)

define gb(holder, resource) (
    perm(Owns(holder, resource))
    // ghostBalance(to, resource).resourceAmount
)

define ghostBalanceAcc(holder, resource) (
    true // acc(ghostBalance(to, resource).resourceAmount
)

define ghostBalanceAtLeast(holder, resource, amt) (
    [true, perm(Owns(holder, resource)) >= (amt / 1)]
)

define ghostBalanceIncreased(holder, resource, amt) (
    [true, perm(Owns(holder, resource)) == old(perm(Owns(holder, resource))) + amt / 1]
    // ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount
)

// Field of returned ref from `balance`
field resourceAmount: Int

method ghostMint(
    to: ResourceHolder, 
    resource: Resource,
    amount: Int
) 
   requires ghostBalanceAcc(to, resource)
   // requires(ghostBalance(to, resource).resourceAmount + amount >= 0)
   ensures ghostBalanceAcc(to, resource)
   ensures ghostBalanceIncreased(to, resource, amount) // ghostBalance(to, resource).resourceAmount == old(ghostBalance(to, resource).resourceAmount) + amount
// {
//     ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
// }

method ghostTransfer(
    from: ResourceHolder, 
    to: ResourceHolder, 
    resource: Resource,
    amount: Int
)
   requires ghostBalanceAcc(from, resource)
   requires ghostBalanceAcc(to, resource)
   requires(amount >= 0)
   requires(ghostBalanceAtLeast(from, resource, amount))
   requires canTransfer(from, to, resource, amount)
   ensures ghostBalanceAcc(from, resource)
   ensures ghostBalanceAcc(to, resource)
   ensures ghostBalanceIncreased(from, resource, 0 - amount)
   ensures ghostBalanceIncreased(to, resource, amount)
   // Sanity check: total sum of resource unchanged
//    ensures (ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount) ==
//            old(ghostBalance(from, resource).resourceAmount + ghostBalance(to, resource).resourceAmount)

// {
//     ghostBalance(from, resource).resourceAmount := ghostBalance(from, resource).resourceAmount - amount
//     ghostBalance(to, resource).resourceAmount := ghostBalance(to, resource).resourceAmount + amount
// }


// NONGHOST

field bankBalances: Map[AccountID, Map[Coin, Map[Path, Int]]]

define isTotal(map) (
    forall acctID : AccountID, c: Coin, p: Path :: hasPath(map, acctID, c, p)
)

define hasPath(map, acctID, c, p) (
    hasCoin(map, acctID, c) && p in map[acctID][c]
)

define hasCoin(map, acctID, c) (
    acctID in map && c in map[acctID]
)

define balancesPositive(map) (
    (forall acctID: AccountID, c: Coin, p: Path :: {map[acctID][c][p]}
        (hasPath(map, acctID, c, p)) ==> map[acctID][c][p] >= 0)
)

define balanceOfP(map, acctID, c, p) (
    hasPath(map, acctID, c, p) ? map[acctID][c][p] : 0
)

define balanceOfM(map, acctID, c) (
    sumValues(map[acctID][c])
)

function balanceOf(map: Map[AccountID, Map[Coin, Map[Path, Int]]], acctID: AccountID, c: Coin): Int
    requires balancesPositive(map)
 {
    hasCoin(map, acctID, c) ? balanceOfM(map, acctID, c) : 0
 }

domain AccountID {
    function toResourceHolder(bank: Ref, acctId: AccountID): ResourceHolder

    axiom injective {
        forall c1: Ref, c2: Ref,  a1 : AccountID, a2: AccountID :: (a1 != a2 ||  c1 != c2) ==> 
            toResourceHolder(c1, a1) != toResourceHolder(c2, a2)
    }
}

define startsWith(path, port, channel) (
    path.isCons && path.headPort == port && path.headChannel == channel
)

define prependPrefix(path, port, channel) (
    Cons(port, channel, path)
)

function dropPrefix(path: Path, port: Port, channel: ChannelEnd): Path 
  requires(startsWith(path, port, channel))
{
    path.tail
}

// Monomorphised
function sumValues(map: Map[Path, Int]): Int
    requires forall p : Path :: {map[p]} p in map ==> map[p] >= 0
    ensures forall p : Path :: {map[p]} p in map ==> map[p] <= result
    ensures map == Map() ==> result == 0

domain Coin {
    function toResource(coin: Coin): Resource

    axiom toResourceInjective {
        forall c1 : Coin, c2: Coin :: c1 != c2 ==> toResource(c1) != toResource(c2)
    }

    function mkCoin(id: Int): Coin
}

define updated(bankBalances, acctID, path, coin, amt)(
       let bb == (acctID in bankBalances ? bankBalances : bankBalances[acctID := Map()])
    in let coinMap == (coin in bb[acctID] ? bb[acctID] : bb[acctID][coin := Map()])
    in let pathMap == (path in coinMap[coin] ? coinMap[coin] : coinMap[coin][path := 0])
    in let newPathMap == (pathMap[path := pathMap[path]+ amt])
    in let newCoinMap == (coinMap[coin := newPathMap])
    in bb[acctID := newCoinMap]
)

define updateBalance(bank, acctID, path, coin, amt){
    bank.bankBalances := updated(bank.bankBalances, acctID, path, coin, amt)
    if(acctID in old(bank.bankBalances) && coin in old(bank.bankBalances[acctID])) {
        assume sumValues(bank.bankBalances[acctID][coin]) == sumValues(old(bank.bankBalances[acctID][coin])) + amt
    } else {
        assume sumValues(bank.bankBalances[acctID][coin]) == amt
    }
}

define bankInvariantsPre(bank) (
    balancesPositive(bank.bankBalances) &&
    [true, (forall acctID : AccountID, c : Coin :: 
            balanceOf(bank.bankBalances, acctID, c) / 1 == 
            gb(toResourceHolder(bank, acctID), toResource(c))
    )]
)

define bankInvariantsPost(bank) (
    balancesPositive(bank.bankBalances) &&
    [(forall acctID : AccountID, c : Coin :: 
            balanceOf(bank.bankBalances, acctID, c) / 1 == 
            gb(toResourceHolder(bank, acctID), toResource(c))
    ), true]
)
define bankResourcesAcc(bank) (
    true // forall acctID: AccountID, c : Coin :: ghostBalanceAcc(toResourceHolder(bank, acctID), toResource(c))
)

define BankPre(bank) (
    acc(bank.bankBalances) && bankResourcesAcc(bank) && bankInvariantsPre(bank) // && isTotal(bank.bankBalances)
)

define BankPost(bank) (
    acc(bank.bankBalances) && bankResourcesAcc(bank) && bankInvariantsPost(bank) // && isTotal(bank.bankBalances)
)

method bankMintTokens(
    bank: Ref,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires BankPre(bank)
    requires amt >= 0
    requires acc(CanMint(toResourceHolder(bank,to), toResource(coin)), amt / 1)
    ensures BankPost(bank)
    ensures bank.bankBalances == updated(old(bank.bankBalances), to, path, coin, amt)
    ensures balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
    ensures success
{
    ghostMint(
        toResourceHolder(bank,to),
        toResource(coin),
        amt
    )
    updateBalance(bank, to, path, coin, amt)
    success := true
}

define bankBurnTokensPre(bankBalances, from, path, coin, amt) (
    hasCoin(bankBalances, from, coin) && 
        path in bankBalances[from][coin] && 
        bankBalances[from][coin][path] >= amt
)

define burnPost(bank, from, path, coin, amt) (
    bank.bankBalances == updated(old(bank.bankBalances), from, path, coin, 0 - amt)
)

method bankBurnTokens(
    bank: Ref,
    from: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires BankPre(bank)
    requires amt >= 0
    requires canBurn(toResourceHolder(bank, from), toResource(coin), amt)
    ensures BankPost(bank)
    ensures success == bankBurnTokensPre(old(bank.bankBalances), from, path, coin, amt)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> burnPost(bank, from, path, coin, amt)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
    ensures !success ==> canBurn(toResourceHolder(bank, from), toResource(coin), amt)
{
    if(bankBurnTokensPre(bank.bankBalances, from, path, coin, amt)) {
        ghostMint(
            toResourceHolder(bank, from),
            toResource(coin),
            0 - amt
        )
        updateBalance(bank, from, path, coin, 0 - amt)
        success := true
    } else {
        success := false
    }
}

define transferBalancePost(
    bank,
    from,
    to,
    path,
    coin,
    amt
) (
    // pathBalanceChangesBy(bank, from, coin, path, (0 - amt)) &&
    // pathBalanceChangesBy(bank, to, coin, path, amt)
    bank.bankBalances == 
        updated(
            updated(old(bank.bankBalances), from, path, coin, 0 - amt),
            to, path, coin, amt
        )
)

define bankTransferTokensPre(bankBalances, from, to, path, coin, amt) (
    from != to && balanceOfP(bankBalances, from, coin, path) >= amt
)

method bankTransferTokens(
    bank: Ref,
    from: AccountID,
    to: AccountID,
    path: Path,
    coin: Coin,
    amt: Int
) returns (success: Bool)
    requires BankPre(bank)
    requires amt >= 0
    requires ghost
    requires canTransfer(
        toResourceHolder(bank, from), 
        toResourceHolder(bank, to), 
        toResource(coin), 
        amt
    )
    ensures BankPost(bank)
    ensures success == bankTransferTokensPre(old(bank.bankBalances), from, to, path, coin, amt)
    ensures !success ==> bank.bankBalances == old(bank.bankBalances)
    ensures success ==> balanceOf(bank.bankBalances, from, coin) == old(balanceOf(bank.bankBalances, from, coin) - amt)
    ensures success ==> balanceOf(bank.bankBalances, to, coin) == old(balanceOf(bank.bankBalances, to, coin) + amt)
    ensures success ==> transferBalancePost(bank, from, to, path, coin, amt)
{
    if(bankTransferTokensPre(bank.bankBalances, from, to, path, coin, amt)) {
       ghostTransfer(
            toResourceHolder(bank, from),
            toResourceHolder(bank, to),
            toResource(coin),
            amt
        )
        updateBalance(bank, from, path, coin, (0 - amt))
        updateBalance(bank, to, path, coin, amt)
        success := true
    } else {
        success := false
    }
}

domain Port {

    function mkPort(id: Int): Port

}

domain ChannelEnd {
    function mkChannelEnd(id: Int): ChannelEnd
}

adt Path {
    Empty()

    Cons(
        headPort: Port,
        headChannel: ChannelEnd,
        tail: Path
    )
}

adt FungibleTokenPacketData {
    PacketData(
        path: Path,
        coin: Coin,
        sender: AccountID,
        receiver: AccountID,
        amount: Int
    )
}

adt Packet {
    _Packet(
        sourcePort: Port,
        sourceChannel: ChannelEnd,
        destPort: Port,
        destChannel: ChannelEnd,
        data: FungibleTokenPacketData
    )
}

function mkPacket(
  sourcePort: Port,
  sourceChannel: ChannelEnd,
  data: FungibleTokenPacketData
): Packet
  ensures result.sourcePort == sourcePort
  ensures result.sourceChannel == sourceChannel
  ensures result.data == data

adt FungibleTokenPacketAcknowledgement {
    Ack(
        success: Bool
    )
}

function escrowAddress(bank: Ref, channel: ChannelEnd): AccountID

define coinBalanceChangesBy(
    bank,
    acctID,
    coin,
    amt
) (
    balanceOf(bank.bankBalances, acctID, coin) == old(balanceOf(bank.bankBalances, acctID, coin)) + amt
)

define pathBalanceChangesBy(bank, acctID, coin, path, amt) (
    balanceOfP(bank.bankBalances, acctID, coin, path) ==
    balanceOfP(old(bank.bankBalances), acctID, coin, path) + amt
)

method sendFungibleTokens(
    bank: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd
) returns (success: Bool, packet: Packet)
   requires BankPre(bank)
   requires amount >= 0
   requires !startsWith(path, sourcePort, sourceChannel) ==> 
        canTransfer(
            toResourceHolder(bank, sender), 
            toResourceHolder(bank, escrowAddress(bank, sourceChannel)), 
            toResource(coin), 
            amount
        )
   requires startsWith(path, sourcePort, sourceChannel) ==> 
        canBurn(toResourceHolder(bank, sender), toResource(coin), amount)
   ensures((!startsWith(path, sourcePort, sourceChannel) && 
     bankTransferTokensPre(
        old(bank.bankBalances),
        sender,
        escrowAddress(bank, sourceChannel),
        path,
        coin,
        amount
     )) ==> success)
   ensures((startsWith(path, sourcePort, sourceChannel) && 
     bankBurnTokensPre(
        old(bank.bankBalances),
        sender,
        path,
        coin,
        amount
     )) ==> success)
   ensures BankPost(bank)
   ensures !success ==> bank.bankBalances == old(bank.bankBalances)
   ensures success ==> (packet == mkPacket(sourcePort, sourceChannel, PacketData(path, coin, sender, receiver, amount)))
   ensures success ==> path == packet.data.path
   ensures success ==> coinBalanceChangesBy(bank, sender, coin, 0 - amount)
   ensures (success && !startsWith(path, sourcePort, sourceChannel)) ==> 
     coinBalanceChangesBy(bank, escrowAddress(bank, sourceChannel), coin, amount)
   ensures (success && !startsWith(path, sourcePort, sourceChannel)) ==> 
     transferBalancePost(bank, sender, escrowAddress(bank, sourceChannel), path, coin, amount)
   ensures (success && startsWith(path, sourcePort, sourceChannel)) ==> 
     burnPost(bank, sender, path, coin, amount)
{
    if(!startsWith(path, sourcePort, sourceChannel)) {
        success := bankTransferTokens(
            bank,
            sender,
            escrowAddress(bank, sourceChannel),
            path,
            coin,
            amount
        )
    } else {
        success := bankBurnTokens(
            bank,
            sender,
            path,
            coin,
            amount
        )
    }
    var data: FungibleTokenPacketData := PacketData(
        path,
        coin,
        sender,
        receiver,
        amount
    )
    packet := mkPacket(sourcePort, sourceChannel, data)
}

method refundTokens(
    bank: Ref,
    packet: Packet
) 
    requires BankPre(bank)
    requires packet.data.amount >= 0
    requires !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canTransfer(
            toResourceHolder(bank, escrowAddress(bank, packet.sourceChannel)),
            toResourceHolder(bank, packet.data.sender),
            toResource(packet.data.coin), 
            packet.data.amount
        )
    requires startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canMint(toResourceHolder(bank, packet.data.sender), toResource(packet.data.coin), packet.data.amount)
    ensures BankPost(bank)
{
    var success: Bool

    if(!startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.sourceChannel),
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.sender,
            packet.data.path,
            packet.data.coin,
            packet.data.amount
        )

    }
}

method onRecvPacket(
    bank: Ref,
    packet: Packet
) returns (ack: FungibleTokenPacketAcknowledgement) 
    requires BankPre(bank)
    requires packet.data.amount >= 0
    requires startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canTransfer(
            toResourceHolder(bank, escrowAddress(bank, packet.destChannel)),
            toResourceHolder(bank, packet.data.receiver),
            toResource(packet.data.coin),
            packet.data.amount
        )
    requires !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        canMint(toResourceHolder(bank, packet.data.receiver), toResource(packet.data.coin), packet.data.amount)
    ensures BankPost(bank)
    ensures(
        (startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) &&
        bankTransferTokensPre(
            old(bank.bankBalances),
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount)) ==> ack.success
    )
    ensures(!startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> ack.success)
    ensures ack.success ==> coinBalanceChangesBy(bank, packet.data.receiver, packet.data.coin, packet.data.amount)
    ensures (ack.success && startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        coinBalanceChangesBy(bank, escrowAddress(bank, packet.destChannel), packet.data.coin, 0 - packet.data.amount)
    ensures (ack.success && startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        transferBalancePost(
            bank, 
            escrowAddress(bank, packet.destChannel), 
            packet.data.receiver, 
            packet.data.path.tail,
            packet.data.coin, 
            packet.data.amount
        )
    ensures(!startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel) ==> 
        bank.bankBalances == updated(
            old(bank.bankBalances), 
            packet.data.receiver,
            prependPrefix(packet.data.path, packet.destPort, packet.destChannel),
            packet.data.coin,
            packet.data.amount
        )
    )
{
    var success: Bool
    if(startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) {
        success := bankTransferTokens(
            bank,
            escrowAddress(bank, packet.destChannel),
            packet.data.receiver,
            dropPrefix(packet.data.path, packet.sourcePort, packet.sourceChannel),
            packet.data.coin,
            packet.data.amount
        )
    } else {
        success := bankMintTokens(
            bank,
            packet.data.receiver,
            prependPrefix(packet.data.path, packet.destPort, packet.destChannel),
            packet.data.coin,
            packet.data.amount
        )
    }
    ack := Ack(success)
}

method onAcknowledgePacket(
    bank: Ref,
    ack: FungibleTokenPacketAcknowledgement,
    packet: Packet
) 
    requires BankPre(bank)
    requires packet.data.amount >= 0
    requires (!ack.success && !startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        canTransfer(
            toResourceHolder(bank, escrowAddress(bank, packet.sourceChannel)), 
            toResourceHolder(bank, packet.data.sender), 
            toResource(packet.data.coin), 
            packet.data.amount
        )
    requires (!ack.success && startsWith(packet.data.path, packet.sourcePort, packet.sourceChannel)) ==> 
        canMint(toResourceHolder(bank, packet.data.sender), toResource(packet.data.coin), packet.data.amount)
    ensures BankPost(bank)
    ensures ack.success ==> bank.bankBalances == old(bank.bankBalances)
{
    if(!ack.success) {
        refundTokens(bank, packet)
    } else {

    }

}

function unused(acctID: AccountID, path: Path, c: Coin): Int

method roundTrip(
    bank1: Ref,
    bank2: Ref,
    path: Path,
    coin: Coin,
    amount: Int,
    sender: AccountID,
    receiver: AccountID,
    sourcePort: Port,
    sourceChannel: ChannelEnd,
    destPort: Port,
    destChannel: ChannelEnd
) 
    requires BankPre(bank1)
    requires BankPre(bank2)
    requires bank1 != bank2
    requires amount >= 0
    requires !startsWith(path, sourcePort, sourceChannel)
    requires canTransfer(
        toResourceHolder(bank1, sender), 
        toResourceHolder(bank1, escrowAddress(bank1, sourceChannel)), 
        toResource(coin), 
        amount
    )
    requires canMint(toResourceHolder(bank2, receiver), toResource(coin), amount)
    requires canBurn(toResourceHolder(bank2, receiver), toResource(coin), amount)
    requires canTransfer(
        toResourceHolder(bank1, escrowAddress(bank1, sourceChannel)), 
        toResourceHolder(bank1, sender), 
        toResource(coin), 
        amount)
    requires bankTransferTokensPre(
        bank1.bankBalances,
        sender,
        escrowAddress(bank1, sourceChannel),
        path,
        coin,
        amount
    )
    ensures BankPost(bank1)
    ensures BankPost(bank2)
    ensures forall acctID: AccountID, c: Coin, p: Path :: {unused(acctID, p, c)}
        balanceOfP(bank1.bankBalances, acctID, c, p) == balanceOfP(old(bank1.bankBalances), acctID, c, p)
    ensures forall acctID: AccountID, c: Coin, p: Path :: {unused(acctID, p, c)}
        balanceOfP(bank2.bankBalances, acctID, c, p) == balanceOfP(old(bank2.bankBalances), acctID, c, p)
{
    var success: Bool
    var packet: Packet

    success, packet := sendFungibleTokens(bank1, path, coin, amount, sender, receiver, sourcePort, sourceChannel)
    assume packet.destPort == destPort
    assume packet.destChannel == destChannel

    var ack: FungibleTokenPacketAcknowledgement 
    ack := onRecvPacket(bank2, packet)
    onAcknowledgePacket(bank1, ack, packet)

    success, packet := sendFungibleTokens(
        bank2, 
        prependPrefix(path, destPort, destChannel), 
        coin, 
        amount, 
        receiver, 
        sender, 
        destPort, 
        destChannel
    )
    assume packet.destChannel == sourceChannel
    assume packet.destPort == sourcePort
    ack := onRecvPacket(bank1, packet)
    onAcknowledgePacket(bank2, ack, packet)
}