domain Snap$m_Path$_beg_$_end_ {
  
  function discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self: Snap$m_Path$_beg_$_end_): Int
  
  function cons$0$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_(): Snap$m_Path$_beg_$_end_
  
  function cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0: Int, _1: Int): Snap$m_Path$_beg_$_end_
  
  function Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self: Snap$m_Path$_beg_$_end_): Int
  
  function Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self: Snap$m_Path$_beg_$_end_): Int
  
  axiom Snap$m_Path$_beg_$_end_$discriminant_range {
    (forall self: Snap$m_Path$_beg_$_end_ :: { discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self) } 0 <= discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self) && discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(self) <= 1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$0$discriminant_axiom {
    discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(cons$0$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_()) == 0
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$injectivity {
    (forall _l_0: Int, _l_1: Int, _r_0: Int, _r_1: Int :: { cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_l_0, _l_1),cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_r_0, _r_1) } cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_l_0, _l_1) == cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_r_0, _r_1) ==> _l_0 == _r_0 && _l_1 == _r_1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$discriminant_axiom {
    (forall _0: Int, _1: Int :: { cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1) } discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) == 1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$0$axiom {
    (forall _0: Int, _1: Int :: { Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) } Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) == _0)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$0$valid {
    (forall self: Snap$m_Path$_beg_$_end_ :: { Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) } 0 <= Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) && Snap$m_Path$_beg_$_end_$1$field$f$0__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) <= 4294967295)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$1$axiom {
    (forall _0: Int, _1: Int :: { Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) } Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_(_0, _1)) == _1)
  }
  
  axiom Snap$m_Path$_beg_$_end_$1$field$f$1$valid {
    (forall self: Snap$m_Path$_beg_$_end_ :: { Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) } 0 <= Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) && Snap$m_Path$_beg_$_end_$1$field$f$1__$TY$__Snap$m_Path$_beg_$_end_$$int$(self) <= 4294967295)
  }
}

field discriminant: Int

field enum_Cons: Ref

field f$0: Ref

field f$1: Ref

field tuple_0: Ref

field tuple_1: Ref

field val_bool: Bool

field val_int: Int

field val_ref: Ref

function m_Path$_beg_$_end_$$discriminant$$__$TY$__m_Path$_beg_$_end_$$int$(self: Ref): Int
  requires acc(m_Path$_beg_$_end_(self), read$())
  ensures 0 <= result && result <= 1
  ensures discriminant$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_$$int$(snap$__$TY$__Snap$m_Path$_beg_$_end_$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_(self)) == result
{
  (unfolding acc(m_Path$_beg_$_end_(self), read$()) in self.discriminant)
}

function snap$__$TY$__Snap$m_Path$_beg_$_end_$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_(self: Ref): Snap$m_Path$_beg_$_end_
  requires acc(m_Path$_beg_$_end_(self), read$())
{
  ((unfolding acc(m_Path$_beg_$_end_(self), read$()) in self.discriminant) == 1 ? cons$1$__$TY$__Snap$m_Path$_beg_$_end_$$int$$$int$$Snap$m_Path$_beg_$_end_((unfolding acc(m_Path$_beg_$_end_(self), read$()) in (unfolding acc(m_Path$_beg_$_end_Cons(self.enum_Cons), read$()) in (unfolding acc(u32(self.enum_Cons.f$0), read$()) in self.enum_Cons.f$0.val_int))), (unfolding acc(m_Path$_beg_$_end_(self), read$()) in (unfolding acc(m_Path$_beg_$_end_Cons(self.enum_Cons), read$()) in (unfolding acc(u32(self.enum_Cons.f$1), read$()) in self.enum_Cons.f$1.val_int)))) : cons$0$__$TY$__Snap$m_Path$_beg_$_end_$Snap$m_Path$_beg_$_end_())
}

function read$(): Perm
  ensures none < result
  ensures result < write


predicate DeadBorrowToken$(borrow: Int) 

predicate bool(self: Ref) {
  acc(self.val_bool, write)
}

predicate m_Path$_beg_$_end_(self: Ref) {
  acc(self.discriminant, write) && (0 <= self.discriminant && self.discriminant <= 1 && (acc(self.enum_Cons, write) && acc(m_Path$_beg_$_end_Cons(self.enum_Cons), write)))
}

predicate m_Path$_beg_$_end_Cons(self: Ref) {
  acc(self.f$0, write) && (acc(u32(self.f$0), write) && (acc(self.f$1, write) && acc(u32(self.f$1), write)))
}

predicate ref$m_Path$_beg_$_end_(self: Ref) 

predicate tuple2$ref$m_Path$_beg_$_end_$ref$m_Path$_beg_$_end_(self: Ref) {
  acc(self.tuple_0, write) && (acc(ref$m_Path$_beg_$_end_(self.tuple_0), write) && (acc(self.tuple_1, write) && acc(ref$m_Path$_beg_$_end_(self.tuple_1), write)))
}

predicate u32(self: Ref) {
  acc(self.val_int, write) && (0 <= self.val_int && self.val_int <= 4294967295)
}

method m_path_eq() returns (_0: Ref)
{
  var __t0: Bool
  var __t1: Bool
  var __t2: Bool
  var __t3: Bool
  var __t4: Bool
  var __t5: Bool
  var __t6: Bool
  var __t7: Bool
  var __t8: Bool
  var _aux_havoc_ref$m_Path$_beg_$_end_: Ref
  var __t9: Int
  var __t10: Int
  var __t11: Bool
  var _old$pre$0: Ref
  var _old$pre$1: Ref
  var _1: Ref
  var _2: Ref
  var _3: Ref
  var _4: Ref
  var _5: Ref
  var _6: Int
  var _7: Int
  var _8: Ref
  var _9: Ref
  var _10: Ref
  var _11: Ref
  var _12: Ref
  var _13: Int
  var _14: Int
  var _15: Ref
  var _16: Int
  var _17: Int
  label start
  // ========== start ==========
  // Def path: "min::path_eq"
  // Span: min.rs:2:1: 8:2 (#0)
  __t0 := false
  __t1 := false
  __t2 := false
  __t3 := false
  __t4 := false
  __t5 := false
  __t6 := false
  __t7 := false
  __t8 := false
  // Preconditions:
  inhale acc(_1.val_ref, write) && (acc(m_Path$_beg_$_end_(_1.val_ref), read$()) && (acc(_2.val_ref, write) && acc(m_Path$_beg_$_end_(_2.val_ref), read$())))
  inhale true
  label pre
  // ========== bb0 ==========
  __t0 := true
  // [mir] StorageLive(_3)
  // [mir] StorageLive(_4)
  // [mir] _4 = _1
  _4 := builtin$havoc_ref()
  inhale acc(_4.val_ref, write)
  _4.val_ref := _1.val_ref
  inhale acc(m_Path$_beg_$_end_(_4.val_ref), read$())
  label l0
  // [mir] StorageLive(_5)
  // [mir] _5 = _2
  _5 := builtin$havoc_ref()
  inhale acc(_5.val_ref, write)
  _5.val_ref := _2.val_ref
  inhale acc(m_Path$_beg_$_end_(_5.val_ref), read$())
  label l1
  // [mir] _3 = (move _4, move _5)
  _3 := builtin$havoc_ref()
  inhale acc(tuple2$ref$m_Path$_beg_$_end_$ref$m_Path$_beg_$_end_(_3), write)
  _aux_havoc_ref$m_Path$_beg_$_end_ := builtin$havoc_ref()
  unfold acc(tuple2$ref$m_Path$_beg_$_end_$ref$m_Path$_beg_$_end_(_3), write)
  _3.tuple_0 := _aux_havoc_ref$m_Path$_beg_$_end_
  inhale acc(_3.tuple_0.val_ref, write)
  _3.tuple_0.val_ref := _4.val_ref
  label l2
  _aux_havoc_ref$m_Path$_beg_$_end_ := builtin$havoc_ref()
  _3.tuple_1 := _aux_havoc_ref$m_Path$_beg_$_end_
  inhale acc(_3.tuple_1.val_ref, write)
  _3.tuple_1.val_ref := _5.val_ref
  label l3
  // [mir] StorageDead(_5)
  // [mir] StorageDead(_4)
  // [mir] FakeRead(ForMatchedPlace(None), _3)
  // [mir] _7 = discriminant((*(_3.0: &Path)))
  _7 := builtin$havoc_int()
  _7 := m_Path$_beg_$_end_$$discriminant$$__$TY$__m_Path$_beg_$_end_$$int$(_3.tuple_0.val_ref)
  // [mir] switchInt(move _7) -> [1_isize: bb2, otherwise: bb1]
  __t9 := _7
  if (__t9 == 1) {
    goto bb0
  }
  goto return
  label bb0
  // ========== l5 ==========
  // MIR edge bb0 --> bb2
  // ========== bb2 ==========
  __t1 := true
  // [mir] _6 = discriminant((*(_3.1: &Path)))
  _6 := builtin$havoc_int()
  _6 := m_Path$_beg_$_end_$$discriminant$$__$TY$__m_Path$_beg_$_end_$$int$(_3.tuple_1.val_ref)
  // [mir] switchInt(move _6) -> [1_isize: bb3, otherwise: bb1]
  __t10 := _6
  if (__t10 == 1) {
    goto bb2
  }
  goto l4
  label bb1
  // ========== bb7 ==========
  __t7 := true
  // [mir] StorageDead(_15)
  // [mir] StorageDead(_12)
  // [mir] StorageDead(_11)
  // [mir] StorageDead(_10)
  // [mir] StorageDead(_9)
  // [mir] StorageDead(_8)
  // [mir] goto -> bb8
  // ========== l22 ==========
  // drop Acc(_13.val_int, write) (Acc(_13.val_int, write))
  // drop Acc(_14.val_int, write) (Acc(_14.val_int, write))
  // drop Acc(_8.val_ref, write) (Acc(_8.val_ref, write))
  // drop Acc(_12.val_bool, write) (Acc(_12.val_bool, write))
  // drop Acc(_6.val_int, write) (Acc(_6.val_int, write))
  // drop Acc(_11.val_ref, write) (Acc(_11.val_ref, write))
  // drop Acc(_9.val_ref, write) (Acc(_9.val_ref, write))
  // drop Acc(_10.val_ref, write) (Acc(_10.val_ref, write))
  goto bb3
  label bb2
  // ========== l7 ==========
  // MIR edge bb2 --> bb3
  // ========== bb3 ==========
  __t3 := true
  // [mir] falseEdge -> [real: bb4, imaginary: bb1]
  // ========== bb4 ==========
  __t4 := true
  // [mir] StorageLive(_8)
  // [mir] _8 = &(((*(_3.0: &Path)) as Cons).0: u32)
  _8 := builtin$havoc_ref()
  inhale acc(_8.val_ref, write)
  unfold acc(m_Path$_beg_$_end_(_3.tuple_0.val_ref), read$())
  unfold acc(m_Path$_beg_$_end_Cons(_3.tuple_0.val_ref.enum_Cons), read$())
  _8.val_ref := _3.tuple_0.val_ref.enum_Cons.f$0
  inhale acc(u32(_8.val_ref), read$())
  label l8
  // [mir] StorageLive(_9)
  // [mir] _9 = &(((*(_3.0: &Path)) as Cons).1: u32)
  _9 := builtin$havoc_ref()
  inhale acc(_9.val_ref, write)
  _9.val_ref := _3.tuple_0.val_ref.enum_Cons.f$1
  inhale acc(u32(_9.val_ref), read$())
  label l9
  // [mir] StorageLive(_10)
  // [mir] _10 = &(((*(_3.1: &Path)) as Cons).0: u32)
  _10 := builtin$havoc_ref()
  inhale acc(_10.val_ref, write)
  unfold acc(m_Path$_beg_$_end_(_3.tuple_1.val_ref), read$())
  unfold acc(m_Path$_beg_$_end_Cons(_3.tuple_1.val_ref.enum_Cons), read$())
  _10.val_ref := _3.tuple_1.val_ref.enum_Cons.f$0
  inhale acc(u32(_10.val_ref), read$())
  label l10
  // [mir] StorageLive(_11)
  // [mir] _11 = &(((*(_3.1: &Path)) as Cons).1: u32)
  _11 := builtin$havoc_ref()
  inhale acc(_11.val_ref, write)
  _11.val_ref := _3.tuple_1.val_ref.enum_Cons.f$1
  inhale acc(u32(_11.val_ref), read$())
  label l11
  // [mir] StorageLive(_12)
  // [mir] StorageLive(_13)
  // [mir] _13 = (*_8)
  _13 := builtin$havoc_int()
  unfold acc(u32(_8.val_ref), read$())
  _13 := _8.val_ref.val_int
  label l12
  // expire_borrows ReborrowingDAG(L11,)

  if (__t4) {
    // expire loan L11
    fold acc(u32(_8.val_ref), read$())
    exhale acc(u32(_8.val_ref), read$())
  }
  // [mir] StorageLive(_14)
  // [mir] _14 = (*_10)
  _14 := builtin$havoc_int()
  unfold acc(u32(_10.val_ref), read$())
  _14 := _10.val_ref.val_int
  label l13
  // expire_borrows ReborrowingDAG(L5,)

  if (__t4) {
    // expire loan L5
    fold acc(u32(_10.val_ref), read$())
    exhale acc(u32(_10.val_ref), read$())
  }
  // [mir] _12 = Eq(move _13, move _14)
  _12 := builtin$havoc_ref()
  inhale acc(_12.val_bool, write)
  _12.val_bool := _13 == _14
  // [mir] StorageDead(_14)
  // [mir] StorageDead(_13)
  // [mir] switchInt(move _12) -> [false: bb5, otherwise: bb6]
  __t11 := _12.val_bool
  if (!__t11) {
    goto l7
  }
  goto l6
  label bb3
  // ========== bb8 ==========
  __t8 := true
  // [mir] StorageDead(_3)
  // [mir] return
  // ========== return ==========
  // Target of any 'return' statement.
  // Exhale postcondition
  label l20
  // Fold predicates for &mut args and transfer borrow permissions to old
  // obtain acc(m_Path$_beg_$_end_(_1.val_ref), write)
  _old$pre$0 := _1.val_ref
  // obtain acc(m_Path$_beg_$_end_(_2.val_ref), write)
  _old$pre$1 := _2.val_ref
  // Fold the result
  fold acc(bool(_0), write)
  // obtain acc(bool(_0), write)
  // Assert possible strengthening
  // Assert functional specification of postcondition
  // Assert type invariants
  assert true
  // Exhale permissions of postcondition (1/3)
  exhale acc(m_Path$_beg_$_end_(_old$pre$0), read$()) && acc(m_Path$_beg_$_end_(_old$pre$1), read$())
  // Exhale permissions of postcondition (2/3)
  exhale acc(bool(_0), write)
  // Exhale permissions of postcondition (3/3)
  goto end_of_method
  label l4
  // ========== l6 ==========
  // MIR edge bb2 --> bb1
  // Expire borrows
  // expire_borrows ReborrowingDAG(L8,L10,L7,L6,)

  if (__t0 && __t0) {
    // expire loan L10
    // transfer perm old[l3](_5.val_ref) --> old[l1](_5.val_ref) // unchecked: false
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    // drop Acc(old[l1](_5.val_ref), write) (Acc(old[l1](_5.val_ref), write))
    // drop Pred(_3.tuple_0.val_ref, read) (Pred(_3.tuple_0.val_ref, read))
  }
  if (__t0 && __t0) {
    // expire loan L6
    // transfer perm old[l3](_4.val_ref) --> old[l0](_4.val_ref) // unchecked: false
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    // drop Acc(old[l0](_4.val_ref), write) (Acc(old[l0](_4.val_ref), write))
    // drop Pred(_3.tuple_1.val_ref, read) (Pred(_3.tuple_1.val_ref, read))
  }
  // ========== l19 ==========
  // drop Acc(_6.val_int, write) (Acc(_6.val_int, write))
  goto l5
  label l5
  // ========== bb1 ==========
  __t2 := true
  // [mir] _0 = const true
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := true
  // [mir] goto -> bb8
  goto bb3
  label l6
  // ========== l14 ==========
  // MIR edge bb4 --> bb6
  // ========== bb6 ==========
  __t5 := true
  // [mir] StorageLive(_15)
  // [mir] StorageLive(_16)
  // [mir] _16 = (*_9)
  _16 := builtin$havoc_int()
  unfold acc(u32(_9.val_ref), read$())
  _16 := _9.val_ref.val_int
  label l16
  // expire_borrows ReborrowingDAG(L4,L7,L6,)

  if (__t4) {
    // expire loan L4
    fold acc(u32(_9.val_ref), read$())
    exhale acc(u32(_9.val_ref), read$())
  }
  if (__t0 && (__t0 && __t4)) {
    // expire loan L6
    // transfer perm old[l3](_4.val_ref) --> old[l0](_4.val_ref) // unchecked: false
    fold acc(m_Path$_beg_$_end_Cons(old[l0](_4.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
  }
  // [mir] StorageLive(_17)
  // [mir] _17 = (*_11)
  _17 := builtin$havoc_int()
  unfold acc(u32(_11.val_ref), read$())
  _17 := _11.val_ref.val_int
  label l17
  // expire_borrows ReborrowingDAG(L9,L8,L10,)

  if (__t4) {
    // expire loan L9
    fold acc(u32(_11.val_ref), read$())
    exhale acc(u32(_11.val_ref), read$())
  }
  if (__t0 && (__t0 && __t4)) {
    // expire loan L10
    // transfer perm old[l3](_5.val_ref) --> old[l1](_5.val_ref) // unchecked: false
    fold acc(m_Path$_beg_$_end_Cons(old[l1](_5.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
  }
  // [mir] _15 = Eq(move _16, move _17)
  _15 := builtin$havoc_ref()
  inhale acc(_15.val_bool, write)
  _15.val_bool := _16 == _17
  // [mir] StorageDead(_17)
  // [mir] StorageDead(_16)
  // [mir] _0 = move _15
  _0 := _15
  label l18
  // [mir] goto -> bb7
  // ========== l21 ==========
  // drop Acc(old[l0](_4.val_ref), write) (Acc(old[l0](_4.val_ref), write))
  // drop Acc(old[l1](_5.val_ref), write) (Acc(old[l1](_5.val_ref), write))
  // drop Acc(_17.val_int, write) (Acc(_17.val_int, write))
  // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
  goto bb1
  label l7
  // ========== l15 ==========
  // MIR edge bb4 --> bb5
  // Expire borrows
  // expire_borrows ReborrowingDAG(L9,L8,L10,L4,L7,L6,)

  if (__t4) {
    // expire loan L9
    exhale acc(u32(_11.val_ref), read$())
  }
  if (__t0 && (__t0 && __t4)) {
    // expire loan L10
    // transfer perm old[l3](_5.val_ref) --> old[l1](_5.val_ref) // unchecked: false
    fold acc(m_Path$_beg_$_end_Cons(old[l1](_5.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    fold acc(m_Path$_beg_$_end_Cons(_3.tuple_0.val_ref.enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(_3.tuple_0.val_ref), read$())
    // drop Pred(_3.tuple_0.val_ref, read) (Pred(_3.tuple_0.val_ref, read))
    // drop Acc(old[l1](_5.val_ref), write) (Acc(old[l1](_5.val_ref), write))
    // drop Pred(_9.val_ref, read) (Pred(_9.val_ref, read))
  }
  if (__t4) {
    // expire loan L4
    exhale acc(u32(_9.val_ref), read$())
  }
  if (__t0 && (__t0 && __t4)) {
    // expire loan L6
    // transfer perm old[l3](_4.val_ref) --> old[l0](_4.val_ref) // unchecked: false
    fold acc(m_Path$_beg_$_end_Cons(old[l0](_4.val_ref).enum_Cons), read$())
    fold acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    // drop Acc(_3.tuple_1.val_ref[enum_Cons].f$0, read) (Pred(_3.tuple_1.val_ref, read))
    // drop Acc(_3.tuple_1.val_ref.discriminant, read) (Pred(_3.tuple_1.val_ref, read))
    // drop Acc(_3.tuple_1.val_ref[enum_Cons].f$1, read) (Pred(_3.tuple_1.val_ref, read))
    // drop Acc(_3.tuple_1.val_ref[enum_Cons], read) (Pred(_3.tuple_1.val_ref, read))
    // drop Pred(_3.tuple_1.val_ref[enum_Cons].f$1, read) (Pred(_3.tuple_1.val_ref, read))
    // drop Pred(_3.tuple_1.val_ref[enum_Cons].f$0, read) (Pred(_3.tuple_1.val_ref, read))
    // drop Acc(old[l0](_4.val_ref), write) (Acc(old[l0](_4.val_ref), write))
    // drop Pred(_11.val_ref, read) (Pred(_11.val_ref, read))
  }
  // ========== bb5 ==========
  __t6 := true
  // [mir] _0 = const false
  _0 := builtin$havoc_ref()
  inhale acc(_0.val_bool, write)
  _0.val_bool := false
  // [mir] goto -> bb7
  goto bb1
  label return
  // ========== l4 ==========
  // MIR edge bb0 --> bb1
  // Expire borrows
  // expire_borrows ReborrowingDAG(L8,L10,L7,L6,)

  if (__t0 && __t0) {
    // expire loan L10
    // transfer perm old[l3](_5.val_ref) --> old[l1](_5.val_ref) // unchecked: false
    exhale acc(m_Path$_beg_$_end_(old[l1](_5.val_ref)), read$())
    // drop Acc(old[l1](_5.val_ref), write) (Acc(old[l1](_5.val_ref), write))
    // drop Pred(_3.tuple_0.val_ref, read) (Pred(_3.tuple_0.val_ref, read))
  }
  if (__t0 && __t0) {
    // expire loan L6
    // transfer perm old[l3](_4.val_ref) --> old[l0](_4.val_ref) // unchecked: false
    exhale acc(m_Path$_beg_$_end_(old[l0](_4.val_ref)), read$())
    // drop Acc(old[l0](_4.val_ref), write) (Acc(old[l0](_4.val_ref), write))
    // drop Pred(_3.tuple_1.val_ref, read) (Pred(_3.tuple_1.val_ref, read))
  }
  goto l5
  label end_of_method
}

method builtin$havoc_bool() returns (ret: Bool)


method builtin$havoc_int() returns (ret: Int)


method builtin$havoc_ref() returns (ret: Ref)
